{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-320dd67550fc622661adc857578957e1f1c69ca0",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/core/selfRecoveryModule.sol": "project/contracts/core/selfRecoveryModule.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.0.2/access/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/abstract/SelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IPoseidonT3} from \"../interfaces/IPoseidonT3.sol\";\nimport {IIdentityVerificationHubV2} from \"../interfaces/IIdentityVerificationHubV2.sol\";\nimport {ISelfVerificationRoot} from \"../interfaces/ISelfVerificationRoot.sol\";\nimport {CircuitConstantsV2} from \"../constants/CircuitConstantsV2.sol\";\nimport {AttestationId} from \"../constants/AttestationId.sol\";\nimport {SelfUtils} from \"../libraries/SelfUtils.sol\";\nimport {Formatter} from \"../libraries/Formatter.sol\";\n\n/**\n * @title SelfVerificationRoot\n * @notice Abstract base contract to be integrated with self's verification infrastructure\n * @dev Provides base functionality for verifying and disclosing identity credentials\n * @author Self Team\n */\nabstract contract SelfVerificationRoot is ISelfVerificationRoot {\n    // ====================================================\n    // Constants\n    // ====================================================\n\n    /// @notice Contract version identifier used in verification process\n    /// @dev This version is included in the hub data for protocol compatibility\n    uint8 constant CONTRACT_VERSION = 2;\n\n    // ====================================================\n    // Storage Variables\n    // ====================================================\n\n    /// @notice The scope value that proofs must match\n    /// @dev Used to validate that submitted proofs match the expected scope\n    uint256 internal _scope;\n\n    /// @notice Reference to the identity verification hub V2 contract\n    /// @dev Immutable reference used for bytes-based proof verification\n    IIdentityVerificationHubV2 internal immutable _identityVerificationHubV2;\n\n    // ====================================================\n    // Errors\n    // ====================================================\n\n    /// @notice Error thrown when the data format is invalid\n    /// @dev Triggered when the provided bytes data doesn't have the expected format\n    error InvalidDataFormat();\n\n    /// @notice Error thrown when onVerificationSuccess is called by an unauthorized address\n    /// @dev Only the identity verification hub V2 contract can call onVerificationSuccess\n    error UnauthorizedCaller();\n\n    // ====================================================\n    // Events\n    // ====================================================\n\n    /**\n     * @notice Initializes the SelfVerificationRoot contract\n     * @dev Sets up the immutable reference to the hub contract and generates scope automatically\n     * @param identityVerificationHubV2Address The address of the Identity Verification Hub V2\n     * @param scopeSeed The scope seed string to be hashed with contract address to generate the scope\n     */\n    constructor(address identityVerificationHubV2Address, string memory scopeSeed) {\n        _identityVerificationHubV2 = IIdentityVerificationHubV2(identityVerificationHubV2Address);\n        _scope = _calculateScope(address(this), scopeSeed, _getPoseidonAddress());\n    }\n\n    /**\n     * @notice Returns the current scope value\n     * @dev Public view function to access the current scope setting\n     * @return The scope value that proofs must match\n     */\n    function scope() public view returns (uint256) {\n        return _scope;\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format proofPayload = | 32 bytes attestationId | proofData |\n     * @custom:data-format userContextData = | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format hubData = | 1 bytes contract version | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proofData |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) public {\n        // Minimum expected length for proofData: 32 bytes attestationId + proof data\n        if (proofPayload.length < 32) {\n            revert InvalidDataFormat();\n        }\n\n        // Minimum userDefinedData length: 32 (destChainId) + 32 (userIdentifier) + 0 (userDefinedData) = 64 bytes\n        if (userContextData.length < 64) {\n            revert InvalidDataFormat();\n        }\n\n        bytes32 attestationId;\n        assembly {\n            // Load attestationId from the beginning of proofData (first 32 bytes)\n            attestationId := calldataload(proofPayload.offset)\n        }\n\n        bytes32 destinationChainId = bytes32(userContextData[0:32]);\n        bytes32 userIdentifier = bytes32(userContextData[32:64]);\n        bytes memory userDefinedData = userContextData[64:];\n\n        bytes32 configId = getConfigId(destinationChainId, userIdentifier, userDefinedData);\n\n        // Hub data should be | 1 byte contractVersion | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proof data\n        bytes memory baseVerificationInput = abi.encodePacked(\n            // 1 byte contractVersion\n            CONTRACT_VERSION,\n            // 31 bytes buffer (all zeros)\n            bytes31(0),\n            // 32 bytes scope\n            _scope,\n            proofPayload\n        );\n\n        // Call hub V2 verification\n        _identityVerificationHubV2.verify(baseVerificationInput, bytes.concat(configId, userContextData));\n    }\n\n    /**\n     * @notice Callback function called upon successful verification by the hub contract\n     * @dev Only callable by the identity verification hub V2 contract for security\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:security Only the authorized hub contract can call this function\n     * @custom:flow This function decodes the output and calls the customizable verification hook\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) public {\n        // Only allow the identity verification hub V2 to call this function\n        if (msg.sender != address(_identityVerificationHubV2)) {\n            revert UnauthorizedCaller();\n        }\n\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory genericDiscloseOutput = abi.decode(\n            output,\n            (ISelfVerificationRoot.GenericDiscloseOutputV2)\n        );\n\n        // Call the customizable verification hook\n        customVerificationHook(genericDiscloseOutput, userData);\n    }\n\n    /**\n     * @notice Generates a configId for the user\n     * @dev This function should be overridden by the implementing contract to provide custom configId logic\n     * @param destinationChainId The destination chain ID\n     * @param userIdentifier The user identifier\n     * @param userDefinedData The user defined data\n     * @return The configId\n     */\n    function getConfigId(\n        bytes32 destinationChainId,\n        bytes32 userIdentifier,\n        bytes memory userDefinedData\n    ) public view virtual returns (bytes32) {\n        // Default implementation reverts; must be overridden in derived contract\n        revert(\"SelfVerificationRoot: getConfigId must be overridden\");\n    }\n\n    /**\n     * @notice Custom verification hook that can be overridden by implementing contracts\n     * @dev This function is called after successful verification and hub address validation\n     * @param output The verification output data from the hub containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:override Override this function in derived contracts to add custom verification logic\n     * @custom:security This function is only called after proper authentication by the hub contract\n     */\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal virtual {\n        // Default implementation is empty - override in derived contracts to add custom logic\n    }\n\n    /**\n     * @notice Gets the PoseidonT3 library address for the current chain\n     * @dev Returns hardcoded addresses of pre-deployed PoseidonT3 library on current chain\n     * @dev For local development networks, should create a setter function to set the scope manually\n     * @return The address of the PoseidonT3 library on this chain\n     */\n    function _getPoseidonAddress() internal view returns (address) {\n        uint256 chainId = block.chainid;\n\n        // Celo Mainnet\n        if (chainId == 42220) {\n            return 0xF134707a4C4a3a76b8410fC0294d620A7c341581;\n        }\n\n        // Celo Sepolia\n        if (chainId == 11142220) {\n            return 0x0a782f7F9f8Aac6E0bacAF3cD4aA292C3275C6f2;\n        }\n\n        // For local/development networks or other chains, return zero address\n        return address(0);\n    }\n\n    /**\n     * @notice Calculates scope from contract address, scope seed, and PoseidonT3 address\n     * @param contractAddress The contract address to hash\n     * @param scopeSeed The scope seed string\n     * @param poseidonT3Address The address of the PoseidonT3 library to use\n     * @return The calculated scope value\n     */\n    function _calculateScope(\n        address contractAddress,\n        string memory scopeSeed,\n        address poseidonT3Address\n    ) internal view returns (uint256) {\n        // Skip calculation if PoseidonT3 address is zero (local development)\n        if (poseidonT3Address == address(0)) {\n            return 0;\n        }\n\n        uint256 addressHash = _calculateAddressHashWithPoseidon(contractAddress, poseidonT3Address);\n        uint256 scopeSeedAsUint = SelfUtils.stringToBigInt(scopeSeed);\n        return IPoseidonT3(poseidonT3Address).hash([addressHash, scopeSeedAsUint]);\n    }\n\n    /**\n     * @notice Calculates hash of contract address using frontend-compatible chunking with specific PoseidonT3\n     * @dev Converts address to hex string, splits into 2 chunks (31+11), and hashes with provided PoseidonT3\n     * @param addr The contract address to hash\n     * @param poseidonT3Address The address of the PoseidonT3 library to use\n     * @return The hash result equivalent to frontend's endpointHash for addresses\n     */\n    function _calculateAddressHashWithPoseidon(\n        address addr,\n        address poseidonT3Address\n    ) internal view returns (uint256) {\n        // Convert address to hex string (42 chars: \"0x\" + 40 hex digits)\n        string memory addressString = SelfUtils.addressToHexString(addr);\n\n        // Split into exactly 2 chunks: 31 + 11 characters\n        // Chunk 1: characters 0-30 (31 chars)\n        // Chunk 2: characters 31-41 (11 chars)\n        uint256 chunk1BigInt = SelfUtils.stringToBigInt(Formatter.substring(addressString, 0, 31));\n        uint256 chunk2BigInt = SelfUtils.stringToBigInt(Formatter.substring(addressString, 31, 42));\n\n        return IPoseidonT3(poseidonT3Address).hash([chunk1BigInt, chunk2BigInt]);\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/constants/AttestationId.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title AttestationId Library\n * @notice This library provides attestation identifiers used across contracts.\n * @dev Currently, it contains the constant E_PASSPORT which represents the identifier\n * for an E-PASSPORT attestation computed as Poseidon(\"E-PASSPORT\").\n */\nlibrary AttestationId {\n    /**\n     * @notice Identifier for an E-PASSPORT attestation.\n     * @dev The identifier is computed based on the hash of \"E-PASSPORT\" using the Poseidon hash function.\n     * Here it is hardcoded as bytes32(uint256(1)) for demonstration purposes.\n     */\n    bytes32 constant E_PASSPORT = bytes32(uint256(1));\n    bytes32 constant EU_ID_CARD = bytes32(uint256(2));\n    bytes32 constant AADHAAR = bytes32(uint256(3));\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/constants/CircuitConstantsV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {AttestationId} from \"./AttestationId.sol\";\n\n/**\n * @title Circuit Constants Library\n * @notice This library defines constants representing indices used to access public signals\n *         of various circuits such as register, DSC, and VC/Disclose.\n * @dev These indices map directly to specific data fields in the corresponding circuits proofs.\n */\nlibrary CircuitConstantsV2 {\n    // ---------------------------\n    // Register Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the nullifier in the register circuit public signals.\n     */\n    uint256 constant REGISTER_NULLIFIER_INDEX = 0;\n\n    /**\n     * @notice Index to access the commitment in the register circuit public signals.\n     */\n    uint256 constant REGISTER_COMMITMENT_INDEX = 1;\n\n    /**\n     * @notice Index to access the Merkle root in the register circuit public signals.\n     */\n    uint256 constant REGISTER_MERKLE_ROOT_INDEX = 2;\n\n    // ---------------------------\n    // DSC Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the tree leaf in the DSC circuit public signals.\n     */\n    uint256 constant DSC_TREE_LEAF_INDEX = 0;\n\n    /**\n     * @notice Index to access the CSCA root in the DSC circuit public signals.\n     */\n    uint256 constant DSC_CSCA_ROOT_INDEX = 1;\n\n    // ---------------------------\n    // Aadhaar Circuit Constants\n    // ---------------------------\n    /**\n     * @notice Index to access the pubkey commitment in the Aadhaar circuit public signals.\n     */\n    uint256 constant AADHAAR_UIDAI_PUBKEY_COMMITMENT_INDEX = 0;\n    uint256 constant AADHAAR_NULLIFIER_INDEX = 1;\n    uint256 constant AADHAAR_COMMITMENT_INDEX = 2;\n    uint256 constant AADHAAR_TIMESTAMP_INDEX = 3;\n\n    // -------------------------------------\n    // VC and Disclose Circuit Constants\n    // -------------------------------------\n\n    /**\n     * @notice Structure containing circuit indices for a specific attestation type.\n     */\n    struct DiscloseIndices {\n        uint256 revealedDataPackedIndex;\n        uint256 forbiddenCountriesListPackedIndex;\n        uint256 nullifierIndex;\n        uint256 attestationIdIndex;\n        uint256 merkleRootIndex;\n        uint256 currentDateIndex;\n        uint256 namedobSmtRootIndex;\n        uint256 nameyobSmtRootIndex;\n        uint256 scopeIndex;\n        uint256 userIdentifierIndex;\n        uint256 passportNoSmtRootIndex;\n    }\n\n    /**\n     * @notice Returns the circuit indices for a given attestation type.\n     * @param attestationId The attestation identifier.\n     * @return indices The DiscloseIndices struct containing all relevant indices.\n     */\n    function getDiscloseIndices(bytes32 attestationId) internal pure returns (DiscloseIndices memory indices) {\n        if (attestationId == AttestationId.E_PASSPORT) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 3,\n                    nullifierIndex: 7,\n                    attestationIdIndex: 8,\n                    merkleRootIndex: 9,\n                    currentDateIndex: 10,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 16\n                });\n        } else if (attestationId == AttestationId.EU_ID_CARD) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 4,\n                    nullifierIndex: 8,\n                    attestationIdIndex: 9,\n                    merkleRootIndex: 10,\n                    currentDateIndex: 11,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 99\n                });\n        } else if (attestationId == AttestationId.AADHAAR) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 2,\n                    forbiddenCountriesListPackedIndex: 6,\n                    nullifierIndex: 0,\n                    attestationIdIndex: 10,\n                    merkleRootIndex: 16,\n                    currentDateIndex: 11,\n                    namedobSmtRootIndex: 14,\n                    nameyobSmtRootIndex: 15,\n                    scopeIndex: 17,\n                    userIdentifierIndex: 18,\n                    passportNoSmtRootIndex: 99\n                });\n        } else {\n            revert(\"Invalid attestation ID\");\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IDscCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title IDscCircuitVerifier\n * @notice Interface for verifying zero-knowledge proofs related to the DSC circuit.\n * @dev This interface defines the structure of a DSC circuit proof and exposes a function to verify such proofs.\n */\ninterface IDscCircuitVerifier {\n    /**\n     * @notice Represents a DSC circuit proof.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of two unsigned integers representing the public signals associated with the proof.\n     */\n    struct DscCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given DSC circuit zero-knowledge proof.\n     * @dev This function checks the validity of the provided DSC proof parameters.\n     * @param pA The 'a' component of the proof.\n     * @param pB The 'b' component of the proof.\n     * @param pC The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata pA,\n        uint256[2][2] calldata pB,\n        uint256[2] calldata pC,\n        uint256[2] calldata pubSignals\n    ) external view returns (bool);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IIdentityVerificationHubV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IRegisterCircuitVerifier} from \"./IRegisterCircuitVerifier.sol\";\nimport {IDscCircuitVerifier} from \"./IDscCircuitVerifier.sol\";\nimport {SelfStructs} from \"../libraries/SelfStructs.sol\";\n\n/**\n * @title IIdentityVerificationHubV2\n * @notice Interface for the Identity Verification Hub V2 for verifying zero-knowledge proofs.\n * @dev Defines all external and public functions from IdentityVerificationHubImplV2.\n */\ninterface IIdentityVerificationHubV2 {\n    // ====================================================\n    // External Functions\n    // ====================================================\n\n    /**\n     * @notice Registers a commitment using a register circuit proof.\n     * @dev Verifies the register circuit proof and then calls the Identity Registry to register the commitment.\n     * @param attestationId The attestation ID.\n     * @param registerCircuitVerifierId The identifier for the register circuit verifier to use.\n     * @param registerCircuitProof The register circuit proof data.\n     */\n    function registerCommitment(\n        bytes32 attestationId,\n        uint256 registerCircuitVerifierId,\n        IRegisterCircuitVerifier.RegisterCircuitProof memory registerCircuitProof\n    ) external;\n\n    /**\n     * @notice Registers a DSC key commitment using a DSC circuit proof.\n     * @dev Verifies the DSC proof and then calls the Identity Registry to register the dsc key commitment.\n     * @param attestationId The attestation ID.\n     * @param dscCircuitVerifierId The identifier for the DSC circuit verifier to use.\n     * @param dscCircuitProof The DSC circuit proof data.\n     */\n    function registerDscKeyCommitment(\n        bytes32 attestationId,\n        uint256 dscCircuitVerifierId,\n        IDscCircuitVerifier.DscCircuitProof memory dscCircuitProof\n    ) external;\n\n    /**\n     * @notice Sets verification config in V2 storage (owner only)\n     * @dev The configId is automatically generated from the config content using sha256(abi.encode(config))\n     * @param config The verification configuration\n     * @return configId The generated config ID\n     */\n    function setVerificationConfigV2(\n        SelfStructs.VerificationConfigV2 memory config\n    ) external returns (bytes32 configId);\n\n    /**\n     * @notice Main verification function with new structured input format\n     * @param baseVerificationInput The base verification input data\n     * @param userContextData The user context data\n     */\n    function verify(bytes calldata baseVerificationInput, bytes calldata userContextData) external;\n\n    /**\n     * @notice Updates the registry address.\n     * @param attestationId The attestation ID.\n     * @param registryAddress The new registry address.\n     */\n    function updateRegistry(bytes32 attestationId, address registryAddress) external;\n\n    /**\n     * @notice Updates the VC and Disclose circuit verifier address.\n     * @param attestationId The attestation ID.\n     * @param vcAndDiscloseCircuitVerifierAddress The new VC and Disclose circuit verifier address.\n     */\n    function updateVcAndDiscloseCircuit(bytes32 attestationId, address vcAndDiscloseCircuitVerifierAddress) external;\n\n    /**\n     * @notice Updates the register circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new register circuit verifier address.\n     */\n    function updateRegisterCircuitVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Updates the DSC circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new DSC circuit verifier address.\n     */\n    function updateDscVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Batch updates register circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new register circuit verifier addresses.\n     */\n    function batchUpdateRegisterCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    /**\n     * @notice Batch updates DSC circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new DSC circuit verifier addresses.\n     */\n    function batchUpdateDscCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    // ====================================================\n    // External View Functions\n    // ====================================================\n\n    /**\n     * @notice Returns the registry address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The registry address associated with the attestation ID.\n     */\n    function registry(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the disclose verifier address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The disclose verifier address associated with the attestation ID.\n     */\n    function discloseVerifier(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the register circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The register circuit verifier address associated with the attestation ID and type ID.\n     */\n    function registerCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the DSC circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The DSC circuit verifier address associated with the attestation ID and type ID.\n     */\n    function dscCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the merkle root timestamp for a given attestation ID and root.\n     * @param attestationId The attestation ID to query.\n     * @param root The merkle root to query.\n     * @return The merkle root timestamp associated with the attestation ID and root.\n     */\n    function rootTimestamp(bytes32 attestationId, uint256 root) external view returns (uint256);\n\n    /**\n     * @notice Returns the identity commitment merkle root for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The identity commitment merkle root associated with the attestation ID.\n     */\n    function getIdentityCommitmentMerkleRoot(bytes32 attestationId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a verification config exists\n     * @param configId The configuration identifier\n     * @return exists Whether the config exists\n     */\n    function verificationConfigV2Exists(bytes32 configId) external view returns (bool exists);\n\n    // ====================================================\n    // Public Functions\n    // ====================================================\n\n    /**\n     * @notice Generates a config ID from a verification config\n     * @param config The verification configuration\n     * @return The generated config ID (sha256 hash of encoded config)\n     */\n    function generateConfigId(SelfStructs.VerificationConfigV2 memory config) external pure returns (bytes32);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IPoseidonT3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title IPoseidonT3\n * @notice Interface for the PoseidonT3 library\n */\ninterface IPoseidonT3 {\n    function hash(uint256[2] memory inputs) external pure returns (uint256);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IRegisterCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n/**\n * @title IRegisterCircuitVerifier\n * @notice Interface for verifying register circuit proofs.\n * @dev This interface defines the structure of a register circuit proof and exposes a function to verify such proofs.\n */\n\nstruct GenericProofStruct {\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n    uint256[] pubSignals;\n}\n\ninterface IRegisterCircuitVerifier {\n    /**\n     * @notice Represents a register circuit proof.\n     * @dev This structure encapsulates the required proof elements.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of three unsigned integers representing the public signals associated with the proof.\n     */\n    struct RegisterCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[3] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given register circuit proof.\n     * @dev This function checks the validity of the provided proof parameters.\n     * @param a The 'a' component of the proof.\n     * @param b The 'b' component of the proof.\n     * @param c The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return isValid A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[3] calldata pubSignals\n    ) external view returns (bool isValid);\n}\n\ninterface IAadhaarRegisterCircuitVerifier {\n    /**\n     * @notice Verifies a given register circuit proof.\n     * @dev This function checks the validity of the provided proof parameters.\n     * @param a The 'a' component of the proof.\n     * @param b The 'b' component of the proof.\n     * @param c The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return isValid A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[4] calldata pubSignals\n    ) external view returns (bool isValid);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/ISelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title ISelfVerificationRoot\n * @notice Interface for self-verification infrastructure integration\n * @dev Provides base functionality for verifying and disclosing identity credentials\n */\ninterface ISelfVerificationRoot {\n    /**\n     * @notice Structure containing proof data for disclose circuits\n     * @dev Contains the proof elements required for zero-knowledge verification\n     * @param a First proof element\n     * @param b Second proof element (2x2 matrix)\n     * @param c Third proof element\n     * @param pubSignals Array of 21 public signals for the circuit\n     */\n    struct DiscloseCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[21] pubSignals;\n    }\n\n    /**\n     * @notice Structure containing verified identity disclosure output data\n     * @dev Contains all disclosed identity information after successful verification\n     * @param attestationId Unique identifier for the identity documents\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Unique nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed representation of forbidden countries list\n     * @param issuingState The state/country that issued the identity document\n     * @param name Array of name components\n     * @param idNumber The identity document number\n     * @param nationality The nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Expiry date of the identity document\n     * @param olderThan Verified age threshold (e.g., 18 for adult verification)\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) compliance flags\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes configId | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) external;\n\n    /**\n     * @notice Callback function called upon successful verification\n     * @dev Only the identity verification hub V2 contract should call this function\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) external;\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/Formatter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title Formatter Library\n * @notice A library providing utility functions to format names, dates, and encode data.\n */\nlibrary Formatter {\n    error InvalidDateLength();\n    error InvalidYearRange();\n    error InvalidMonthRange();\n    error InvalidDayRange();\n    error InvalidFieldElement();\n    error InvalidDateDigit();\n\n    uint256 constant MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /**\n     * @notice Formats a full name string into first name(s) and last name.\n     * @dev The input is expected to contain a last name, followed by a \"<<\" separator and then first name(s).\n     *      The returned array contains the first names at index 0 and the last name at index 1.\n     * @param input The input string structured as \"lastName<<firstName(s)\".\n     * @return names An array of two strings: [firstName(s), lastName].\n     */\n    function formatName(string memory input) internal pure returns (string[] memory) {\n        bytes memory inputBytes = bytes(input);\n        bytes memory firstNameBytes;\n        bytes memory lastNameBytes;\n        string[] memory names = new string[](2);\n\n        uint256 i = 0;\n        // Extract last name\n        while (i < inputBytes.length && inputBytes[i] != \"<\") {\n            lastNameBytes = abi.encodePacked(lastNameBytes, inputBytes[i]);\n            i++;\n        }\n\n        // Skip the separator \"<<\".\n        i += 2;\n\n        // Extract first names.\n        while (i < inputBytes.length) {\n            if (inputBytes[i] == \"<\") {\n                if (i + 1 < inputBytes.length && inputBytes[i + 1] == \"<\") {\n                    break;\n                }\n                firstNameBytes = abi.encodePacked(firstNameBytes, \" \");\n            } else {\n                firstNameBytes = abi.encodePacked(firstNameBytes, inputBytes[i]);\n            }\n            i++;\n        }\n\n        names[0] = string(firstNameBytes);\n        names[1] = string(lastNameBytes);\n        return names;\n    }\n\n    /**\n     * @notice Formats a compact date string into a human-readable date.\n     * @dev Expects the input date string to have exactly 6 characters in YYMMDD format.\n     *      Returns the date in \"DD-MM-YY\" format.\n     * @param date A string representing the date in YYMMDD format.\n     * @return A formatted date string in the format \"DD-MM-YY\".\n     */\n    function formatDate(string memory date) internal pure returns (string memory) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        string memory year = substring(date, 0, 2);\n        string memory month = substring(date, 2, 4);\n        string memory day = substring(date, 4, 6);\n\n        return string(abi.encodePacked(day, \"-\", month, \"-\", year));\n    }\n\n    /**\n     * @notice Formats a full year date string into a human-readable date.\n     * @dev Expects the input date string to have exactly 8 characters in YYYYMMDD format.\n     *      Returns the date in \"YYYY-MM-DD\" format.\n     * @param date A string representing the date in YYYYMMDD format.\n     * @return A formatted date string in the format \"YYYY-MM-DD\".\n     */\n    function formatDateFullYear(string memory date) internal pure returns (string memory) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 8) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[4] > \"1\" || (dateBytes[4] == \"1\" && dateBytes[5] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[6] > \"3\" || (dateBytes[6] == \"3\" && dateBytes[7] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        string memory year = substring(date, 0, 4);\n        string memory month = substring(date, 4, 6);\n        string memory day = substring(date, 6, 8);\n\n        return string(abi.encodePacked(day, \"-\", month, \"-\", year));\n    }\n\n    /**\n     * @notice Converts an ASCII numeral code to its corresponding unsigned integer.\n     * @dev The input must represent an ASCII code for digits (0-9), i.e. between 48 and 57.\n     *      Reverts with InvalidAsciiCode if the input is out of range.\n     * @param numAscii The ASCII code of a digit character.\n     * @return The numeric value (0-9) corresponding to the ASCII code.\n     */\n    function numAsciiToUint(uint256 numAscii) internal pure returns (uint256) {\n        return (numAscii - 48);\n    }\n\n    /**\n     * @notice Converts an array of three field elements into a bytes representation.\n     * @dev Each element is converted into a specific number of bytes: 31, 31, and 31 respectively.\n     * @param publicSignals An array of three unsigned integers representing field elements.\n     * @return bytesArray A bytes array of total length 93 that encodes the three field elements.\n     */\n    function fieldElementsToBytes(uint256[3] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[3] memory bytesCount = [31, 31, 31];\n        bytes memory bytesArray = new bytes(93);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    function fieldElementsToBytesIdCard(uint256[4] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD ||\n            publicSignals[3] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[4] memory bytesCount = [31, 31, 31, 1];\n        bytes memory bytesArray = new bytes(94);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    function fieldElementsToBytesAadhaar(uint256[4] memory publicSignals) internal pure returns (bytes memory) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (publicSignals[i] >= SNARK_SCALAR_FIELD) {\n                revert InvalidFieldElement();\n            }\n        }\n\n        uint8[4] memory bytesCount = [31, 31, 31, 26];\n        bytes memory bytesArray = new bytes(119);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n\n        return bytesArray;\n    }\n\n    /**\n     * @notice Extracts forbidden country codes from a packed uint256.\n     * @dev Each forbidden country is represented by 3 bytes in the packed data.\n     *      The function extracts up to MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH forbidden countries.\n     * @param publicSignals A packed uint256 containing encoded forbidden country data.\n     * @return forbiddenCountries An array of strings representing the forbidden country codes.\n     */\n    function extractForbiddenCountriesFromPacked(\n        uint256[4] memory publicSignals\n    ) internal pure returns (string[MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH] memory forbiddenCountries) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (publicSignals[i] >= SNARK_SCALAR_FIELD) {\n                revert InvalidFieldElement();\n            }\n        }\n\n        for (uint256 j = 0; j < MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH; j++) {\n            uint256 byteIndex = (j * 3) % 93;\n            uint256 index = j / 31;\n\n            if (byteIndex + 2 < 31) {\n                uint256 shift = byteIndex * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[index * 3] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 31) {\n                uint256 part0 = (publicSignals[0] >> (byteIndex * 8));\n                uint256 part1 = publicSignals[1] & 0x00ffff;\n                uint256 reversedPart1 = ((part1 & 0xff) << 8) | ((part1 & 0xff00) >> 8);\n                uint256 combined = reversedPart1 | (part0 << 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex + 2 < 62) {\n                uint256 byteIndexIn1 = byteIndex - 31;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[1] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 62) {\n                uint256 part0 = (publicSignals[1] >> ((byteIndex - 31) * 8)) & 0x00ffff;\n                uint256 reversedPart0 = ((part0 & 0xff) << 8) | ((part0 & 0xff00) >> 8);\n                uint256 part1 = publicSignals[2] & 0x0000ff;\n                uint256 combined = part1 | (reversedPart0 << 8);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex < 93) {\n                uint256 byteIndexIn1 = byteIndex - 62;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[2] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            }\n        }\n\n        return forbiddenCountries;\n    }\n\n    /**\n     * @notice Converts an array of 6 numerical values representing a date into a Unix timestamp.\n     * @dev Each element in the dateNum array is taken modulo 10, converted to its ASCII digit,\n     *      and concatenated to form a date string in YYMMDD format. This string is then converted\n     *      into a Unix timestamp using dateToUnixTimestamp.\n     * @param dateNum An array of 6 unsigned integers representing a date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the provided date.\n     */\n    function proofDateToUnixTimestamp(uint256[6] memory dateNum) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 6; i++) {\n            if (dateNum[i] > 9) {\n                revert InvalidDateDigit();\n            }\n        }\n        string memory date = \"\";\n        for (uint256 i = 0; i < 6; i++) {\n            date = string(abi.encodePacked(date, bytes1(uint8(48 + (dateNum[i] % 10)))));\n        }\n        uint256 currentTimestamp = dateToUnixTimestamp(date);\n        return currentTimestamp;\n    }\n\n    /**\n     * @notice Converts an array of 3 numerical values representing a date into a Unix timestamp.\n     * @dev The input is expected to be in the format [year, month, day] and is not padded with 0s.\n     * @param dateNum An array of 3 unsigned integers representing a date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the provided date.\n     */\n    function proofDateToUnixTimestampNumeric(uint256[3] memory dateNum) internal pure returns (uint256) {\n        if (dateNum[1] > 12 || dateNum[2] > 31) {\n            revert InvalidDateDigit();\n        }\n        return toTimestamp(dateNum[0], dateNum[1], dateNum[2]);\n    }\n\n    /**\n     * @notice Converts a date string in YYMMDD format into a Unix timestamp.\n     * @dev Parses the date string by extracting year, month, and day components using substring,\n     *      converts each component to an integer, and then computes the timestamp via toTimestamp.\n     *      Reverts if the input string is not exactly 6 characters long.\n     * @param date A 6-character string representing the date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the input date.\n     */\n    function dateToUnixTimestamp(string memory date) internal pure returns (uint256) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        uint256 year = parseDatePart(substring(date, 0, 2)) + 2000;\n        uint256 month = parseDatePart(substring(date, 2, 4));\n        uint256 day = parseDatePart(substring(date, 4, 6));\n\n        return toTimestamp(year, month, day);\n    }\n\n    /**\n     * @notice Extracts a substring from a given string.\n     * @dev Returns the substring from startIndex (inclusive) to endIndex (exclusive).\n     * @param str The input string.\n     * @param startIndex The starting index of the substring (inclusive).\n     * @param endIndex The ending index of the substring (exclusive).\n     * @return The resulting substring.\n     */\n    function substring(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n\n        return string(result);\n    }\n\n    /**\n     * @notice Parses a numeric string and returns its unsigned integer representation.\n     * @dev Assumes the input string contains only numeric characters.\n     * @param value The string representing a number.\n     * @return result The parsed unsigned integer.\n     */\n    function parseDatePart(string memory value) internal pure returns (uint256) {\n        bytes memory tempEmptyStringTest = bytes(value);\n        if (tempEmptyStringTest.length == 0) {\n            return 0;\n        }\n\n        uint256 digit;\n        uint256 result;\n        for (uint256 i = 0; i < tempEmptyStringTest.length; i++) {\n            digit = uint8(tempEmptyStringTest[i]) - 48;\n            result = result * 10 + digit;\n        }\n        return result;\n    }\n\n    /**\n     * @notice Converts a specific date into a Unix timestamp.\n     * @dev Calculates the timestamp by summing the number of days for years, months, and days since January 1, 1970.\n     *      Takes leap years into account during the calculation.\n     * @param year The full year (e.g., 2023).\n     * @param month The month (1-12).\n     * @param day The day of the month.\n     * @return timestamp The Unix timestamp corresponding to the given date.\n     */\n    function toTimestamp(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 timestamp) {\n        uint16 i;\n\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (month < 1 || month > 12) {\n            revert InvalidMonthRange();\n        }\n\n        // Year.\n        for (i = 1970; i < year; i++) {\n            if (isLeapYear(i)) {\n                timestamp += 366 days;\n            } else {\n                timestamp += 365 days;\n            }\n        }\n\n        // Month.\n        uint8[12] memory monthDayCounts;\n        monthDayCounts[0] = 31;\n        if (isLeapYear(year)) {\n            monthDayCounts[1] = 29;\n        } else {\n            monthDayCounts[1] = 28;\n        }\n        monthDayCounts[2] = 31;\n        monthDayCounts[3] = 30;\n        monthDayCounts[4] = 31;\n        monthDayCounts[5] = 30;\n        monthDayCounts[6] = 31;\n        monthDayCounts[7] = 31;\n        monthDayCounts[8] = 30;\n        monthDayCounts[9] = 31;\n        monthDayCounts[10] = 30;\n        monthDayCounts[11] = 31;\n\n        if (day < 1 || day > monthDayCounts[month - 1]) {\n            revert InvalidDayRange();\n        }\n\n        for (i = 1; i < month; i++) {\n            timestamp += monthDayCounts[i - 1] * 1 days;\n        }\n\n        // Day.\n        timestamp += (day - 1) * 1 days;\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Checks whether a given year is a leap year.\n     * @param year The year to check.\n     * @return True if the year is a leap year, otherwise false.\n     */\n    function isLeapYear(uint256 year) internal pure returns (bool) {\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (year % 4 != 0) {\n            return false;\n        } else if (year % 100 != 0) {\n            return true;\n        } else if (year % 400 != 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/SelfStructs.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title SelfStructs\n * @dev Library containing data structures for Self protocol identity verification\n * @notice Defines structs for passport verification, EU ID verification, and generic disclosure outputs\n */\nlibrary SelfStructs {\n    /**\n     * @dev Header structure for Hub input containing contract version and scope information\n     * @param contractVersion Version of the contract being used\n     * @param scope Scope identifier for the verification request\n     * @param attestationId Unique identifier for the attestation\n     */\n    struct HubInputHeader {\n        uint8 contractVersion;\n        uint256 scope;\n        bytes32 attestationId;\n    }\n\n    /**\n     * @dev Output structure for passport verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct PassportOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /**\n     * @dev Output structure for EU ID verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct EuIdOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /**\n     * @dev Output structure for Aadhaar verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     */\n    struct AadhaarOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /// @dev OFAC verification mode: Passport number only\n    uint256 constant passportNoOfac = 0;\n    /// @dev OFAC verification mode: Name and date of birth\n    uint256 constant nameAndDobOfac = 1;\n    /// @dev OFAC verification mode: Name and year of birth\n    uint256 constant nameAndYobOfac = 2;\n\n    /**\n     * @dev Generic disclosure output structure (Version 2) with detailed personal information\n     * @param attestationId Unique identifier for the attestation\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param issuingState Country or state that issued the document\n     * @param name Array of name components (first, middle, last names)\n     * @param idNumber Government-issued identification number\n     * @param nationality Nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Document expiration date in string format\n     * @param olderThan Minimum age verification result\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) verification results for different modes\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 1)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV1 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 2)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV2 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/SelfUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\nimport {SelfStructs} from \"./SelfStructs.sol\";\n\nlibrary SelfUtils {\n    struct UnformattedVerificationConfigV2 {\n        uint256 olderThan;\n        string[] forbiddenCountries;\n        bool ofacEnabled;\n    }\n\n    /**\n     * @dev Packs an array of forbidden countries into chunks suitable for circuit inputs\n     * @param forbiddenCountries Array of 3-character country codes\n     * @return output Array of 4 uint256 values containing packed country data\n     */\n    function packForbiddenCountriesList(\n        string[] memory forbiddenCountries\n    ) internal pure returns (uint256[4] memory output) {\n        uint256 MAX_BYTES_IN_FIELD = 31;\n        uint256 REQUIRED_CHUNKS = 4;\n\n        // Convert country codes to bytes array\n        bytes memory packedBytes;\n\n        // Validate and pack country codes\n        for (uint256 i = 0; i < forbiddenCountries.length; i++) {\n            bytes memory countryBytes = bytes(forbiddenCountries[i]);\n\n            // Validate country code length\n            require(countryBytes.length == 3, \"Invalid country code: must be exactly 3 characters long\");\n\n            // Append country code bytes\n            packedBytes = abi.encodePacked(packedBytes, countryBytes);\n        }\n\n        uint256 maxBytes = packedBytes.length;\n        uint256 packSize = MAX_BYTES_IN_FIELD;\n        uint256 numChunks = (maxBytes + packSize - 1) / packSize; // Ceiling division\n\n        // Pack bytes into chunks\n        for (uint256 i = 0; i < numChunks && i < REQUIRED_CHUNKS; i++) {\n            uint256 sum = 0;\n\n            for (uint256 j = 0; j < packSize; j++) {\n                uint256 idx = packSize * i + j;\n                if (idx < maxBytes) {\n                    uint256 value = uint256(uint8(packedBytes[idx]));\n                    uint256 shift = 8 * j;\n                    sum += value << shift;\n                }\n            }\n\n            output[i] = sum;\n        }\n\n        // Remaining elements are already initialized to 0\n        return output;\n    }\n\n    /**\n     * @dev Formats an unstructured verification configuration into the standardized circuit-compatible format\n     *\n     * This function transforms a simplified input structure into the complete verification configuration\n     * required by the verification config required by the hub.\n     *\n     * @notice Enabled Status Logic:\n     * - `olderThanEnabled`: Automatically set to `true` when `olderThan > 0`\n     * - `forbiddenCountriesEnabled`: Automatically set to `true` when `forbiddenCountries.length > 0`\n     * - `ofacEnabled`: Uses the provided boolean value, replicated across all 3 OFAC check levels\n     *\n     *\n     * @param unformattedVerificationConfigV2 The simplified input configuration containing:\n     *        - `olderThan`: Minimum age threshold (0 = disabled, >0 = enabled)\n     *        - `forbiddenCountries`: Array of 3-letter country codes (empty = disabled, non-empty = enabled)\n     *        - `ofacEnabled`: Boolean flag for all OFAC verification levels\n     *\n     * @return verificationConfigV2 The formatted configuration ready for circuit consumption with:\n     *         - Auto-computed enabled flags based on input values\n     *         - Packed forbidden countries list for efficient circuit processing\n     *         - Replicated OFAC settings across all verification levels\n     */\n    function formatVerificationConfigV2(\n        UnformattedVerificationConfigV2 memory unformattedVerificationConfigV2\n    ) internal pure returns (SelfStructs.VerificationConfigV2 memory verificationConfigV2) {\n        bool[3] memory ofacArray;\n        ofacArray[0] = unformattedVerificationConfigV2.ofacEnabled;\n        ofacArray[1] = unformattedVerificationConfigV2.ofacEnabled;\n        ofacArray[2] = unformattedVerificationConfigV2.ofacEnabled;\n\n        verificationConfigV2 = SelfStructs.VerificationConfigV2({\n            olderThanEnabled: unformattedVerificationConfigV2.olderThan > 0,\n            olderThan: unformattedVerificationConfigV2.olderThan,\n            forbiddenCountriesEnabled: unformattedVerificationConfigV2.forbiddenCountries.length > 0,\n            forbiddenCountriesListPacked: packForbiddenCountriesList(\n                unformattedVerificationConfigV2.forbiddenCountries\n            ),\n            ofacEnabled: ofacArray\n        });\n    }\n\n    /**\n     * @notice Convert string to BigInt using ASCII encoding\n     * @dev Converts each character to its ASCII value and packs them into a uint256\n     * @param str The input string (must be ASCII only, max 31 bytes)\n     * @return The resulting BigInt value\n     */\n    function stringToBigInt(string memory str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(str);\n        require(strBytes.length <= 31, \"String too long for BigInt conversion\");\n\n        uint256 result = 0;\n        for (uint256 i = 0; i < strBytes.length; i++) {\n            // Ensure ASCII only (0-127)\n            require(uint8(strBytes[i]) <= 127, \"Non-ASCII character detected\");\n            result = (result << 8) | uint256(uint8(strBytes[i]));\n        }\n        return result;\n    }\n\n    /**\n     * @notice Converts an address to its lowercase hex string representation\n     * @dev Produces a string like \"0x1234567890abcdef...\" (42 characters total)\n     * @param addr The address to convert\n     * @return The hex string representation of the address\n     */\n    function addressToHexString(address addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(str);\n    }\n}\n"
      },
      "project/contracts/core/selfRecoveryModule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/*\n ProofOfOwner.sol\n\n - Inherits SelfVerificationRoot from @selfxyz/contracts (your installed package)\n - On successful Self verification, recovers the profile of a user\n   writes result back to a VerseProfile contract via a minimal interface.\n\n*/\n\nimport \"@selfxyz/contracts/contracts/abstract/SelfVerificationRoot.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SelfUtils} from \"@selfxyz/contracts/contracts/libraries/SelfUtils.sol\";\nimport {SelfStructs} from \"@selfxyz/contracts/contracts/libraries/SelfStructs.sol\";\nimport {IIdentityVerificationHubV2} from \"@selfxyz/contracts/contracts/interfaces/IIdentityVerificationHubV2.sol\";\nimport {IVerseProfile} from \"../interfaces/IVerseProfile.sol\";\n\ncontract selfRecoveryModule is AccessControl, SelfVerificationRoot {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    /// @notice reference to VerseProfile contract (single source of truth)\n    address public verseProfile;\n\n    /// @notice config id returned by getConfigId (optional)\n    bytes32 public verificationConfigId;\n\n    /// @notice  scope seed recorded locally (for SDK/frontend)\n    string public scopeSeed = \"proof-of-owner\";\n\n    /// @notice events\n    event HumanVerified(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 output,\n        uint256 timestamp,\n        bytes userData\n    );\n\n    event VerificationConfigIdUpdated(bytes32 configId);\n    event VerseProfileUpdated(address indexed verseProfile);\n\n    error ZeroAddress();\n    error NotVerified(address who);\n\n    constructor(\n        address identityVerificationHub\n    ) SelfVerificationRoot(identityVerificationHub, scopeSeed) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n\n        // -----------------------------------------\n        // Build  verification config\n        // -----------------------------------------\n        SelfUtils.UnformattedVerificationConfigV2 memory rawCfg = SelfUtils\n            .UnformattedVerificationConfigV2({\n                olderThan: 0, // No age restriction\n                forbiddenCountries: new string[](0), // Allow all countries\n                ofacEnabled: false // No sanctions screening\n            });\n\n        // -----------------------------------------\n        // Format config for the Hub\n        // -----------------------------------------\n        SelfStructs.VerificationConfigV2 memory formatted = SelfUtils\n            .formatVerificationConfigV2(rawCfg);\n\n        // -----------------------------------------\n        // Register with the Identity Hub (Self)\n        // -----------------------------------------\n        verificationConfigId = IIdentityVerificationHubV2(\n            identityVerificationHub\n        ).setVerificationConfigV2(formatted);\n    }\n\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal override {\n        address subject;\n        bytes32 dochash;\n        address verifier = address(uint160(output.userIdentifier));\n        require(\n            userData.length == 20 || userData.length == 32,\n            \"BAD_USER_DATA_LEN\"\n        );\n\n        if (userData.length == 20) {\n            // packed 20-byte address from abi.encodePacked(address)\n            subject = address(uint160(bytes20(userData)));\n        } else {\n            // standard abi.encode(address)\n            subject = abi.decode(userData, (address));\n        }\n\n        dochash = keccak256(\n            abi.encode(\n                keccak256(\"alpha:human:v1\"),\n                output.name,\n                output.nationality,\n                output.dateOfBirth,\n                output.gender,\n                output.issuingState\n            )\n        );\n\n        if (verseProfile == address(0)) revert ZeroAddress();\n        IVerseProfile vp = IVerseProfile(verseProfile);\n        uint256 verseId = vp.verseIdOfOwner(subject);\n        require(verseId != 0, \"NO_PROFILE_FOR_SUBJECT\");\n\n        bytes32 verifiedHash = vp.getDochash(verseId);\n        require(verifiedHash != bytes32(\"\"), \"PROFILE_NOT_VERIFIED\");\n\n        if (verifiedHash == dochash) {\n            vp.recoverySetOwner(verseId, verifier);\n        }\n    }\n\n    // -------------------------\n    // Admin utilities\n    // -------------------------\n    function setVerseProfile(\n        address _verseProfile\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_verseProfile == address(0)) revert ZeroAddress();\n        verseProfile = _verseProfile;\n        emit VerseProfileUpdated(_verseProfile);\n    }\n\n    function setConfigId(bytes32 configId_) external onlyRole(ADMIN_ROLE) {\n        verificationConfigId = configId_;\n        emit VerificationConfigIdUpdated(configId_);\n    }\n\n    // -------------------------\n    // Self override to provide config id for verification\n    // -------------------------\n    // This returns the config id to the hub when requested. Frontend and contract config must match.\n    function getConfigId(\n        bytes32,\n        bytes32,\n        bytes memory\n    ) public view override returns (bytes32) {\n        return verificationConfigId;\n    }\n}\n"
      },
      "project/contracts/interfaces/IVerseProfile.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IVerseProfile\n/// @notice Interface for interacting with the VerseProfile identity contract.\ninterface IVerseProfile {\n    struct Profile {\n        address owner; // wallet or smart account\n        string handle; // globally unique, normalized lowercase\n        string metadataURI; // ipfs://... or https://...\n        string purpose; // human-readable purpose\n        address delegate; // optional manager/guardian\n        uint64 createdAt; // block.timestamp\n        uint8 version; // schema version\n        bytes32 dochash; // proof of verification\n    }\n    struct ProfileSum {\n        address owner;\n        string handle;\n        string metadataURI;\n        string purpose;\n        address delegate;\n        uint64 createdAt;\n        uint8 version;\n        bool verified;\n    }\n\n    // -------- Views --------\n    function getProfile(uint256 verseId) external view returns (Profile memory);\n\n    function getDochash(uint256 verseId) external view returns (bytes32);\n\n    function verseIdByHandle(\n        string calldata handle\n    ) external view returns (uint256);\n\n    function verseIdOfOwner(address owner) external view returns (uint256);\n\n    function getAppNickname(\n        uint256 verseId,\n        bytes32 appId\n    ) external view returns (string memory);\n\n    function verseIdByAppNickname(\n        bytes32 appId,\n        string calldata nickname\n    ) external view returns (uint256);\n\n    function hasProfile(address user) external view returns (bool);\n\n    function getDisplayHandle(\n        uint256 verseId,\n        bytes32 appId\n    ) external view returns (string memory);\n\n    function profileOf(address user) external view returns (uint256);\n\n    // -------- Mutative --------\n    function createProfile(\n        string calldata verseHandle,\n        string calldata metadataURI,\n        bytes32 ensNamehash\n    ) external returns (uint256 verseId);\n\n    function setVerseHandle(\n        uint256 verseId,\n        string calldata newHandle\n    ) external;\n\n    function recoverySetOwner(uint256 verseId, address newOwner) external;\n\n    function setHumanVerified(address subject, bytes32 dochash) external;\n\n    function setMetadataURI(uint256 verseId, string calldata newURI) external;\n\n    function transferOwnershipOfProfile(\n        uint256 verseId,\n        address newOwner\n    ) external;\n\n    function setAppNickname(\n        uint256 verseId,\n        bytes32 appId,\n        string calldata nickname\n    ) external;\n}\n"
      }
    }
  }
}