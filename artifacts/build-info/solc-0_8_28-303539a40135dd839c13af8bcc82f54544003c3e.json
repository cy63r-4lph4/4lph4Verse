{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-303539a40135dd839c13af8bcc82f54544003c3e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": "npm/@openzeppelin/contracts@5.0.2/proxy/ERC1967/ERC1967Proxy.sol",
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": "npm/@openzeppelin/contracts@5.0.2/proxy/transparent/ProxyAdmin.sol",
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": "npm/@openzeppelin/contracts@5.0.2/proxy/transparent/TransparentUpgradeableProxy.sol",
    "contracts/badges/BadgeRegistry.sol": "project/contracts/badges/BadgeRegistry.sol",
    "contracts/core/AppRegistry.sol": "project/contracts/core/AppRegistry.sol",
    "contracts/core/CoreFaucet.sol": "project/contracts/core/CoreFaucet.sol",
    "contracts/core/CoreToken.sol": "project/contracts/core/CoreToken.sol",
    "contracts/core/GuardianRecoveryModule.sol": "project/contracts/core/GuardianRecoveryModule.sol",
    "contracts/core/HumanVerificationModule.sol": "project/contracts/core/HumanVerificationModule.sol",
    "contracts/core/ReputationHub.sol": "project/contracts/core/ReputationHub.sol",
    "contracts/core/ScoreAggregator.sol": "project/contracts/core/ScoreAggregator.sol",
    "contracts/core/ScoreModelBase.sol": "project/contracts/core/ScoreModelBase.sol",
    "contracts/core/selfRecoveryModule.sol": "project/contracts/core/selfRecoveryModule.sol",
    "contracts/core/VerseProfile.sol": "project/contracts/core/VerseProfile.sol",
    "contracts/hirecore/HireCoreScoreModel.sol": "project/contracts/hirecore/HireCoreScoreModel.sol",
    "contracts/hirecore/JobBoard.sol": "project/contracts/hirecore/JobBoard.sol",
    "contracts/hirecore/JobManager.sol": "project/contracts/hirecore/JobManager.sol",
    "contracts/interfaces/IBadgeRegistry.sol": "project/contracts/interfaces/IBadgeRegistry.sol",
    "contracts/interfaces/IJobManager.sol": "project/contracts/interfaces/IJobManager.sol",
    "contracts/interfaces/IScoreModel.sol": "project/contracts/interfaces/IScoreModel.sol",
    "contracts/interfaces/IVerseAppRegistry.sol": "project/contracts/interfaces/IVerseAppRegistry.sol",
    "contracts/interfaces/IVerseProfile.sol": "project/contracts/interfaces/IVerseProfile.sol",
    "contracts/interfaces/IVerseReputationHub.sol": "project/contracts/interfaces/IVerseReputationHub.sol",
    "contracts/interfaces/IVerseScoreAggregator.sol": "project/contracts/interfaces/IVerseScoreAggregator.sol",
    "contracts/utils/GatingLib.sol": "project/contracts/utils/GatingLib.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "npm/@openzeppelin/contracts-upgradeable@5.0.2/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.3/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/",
        "project/:@verse/contracts/=project/contracts/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/access/AccessControlUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/UUPSUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/token/ERC1155/ERC1155Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155\n    struct ERC1155Storage {\n        mapping(uint256 id => mapping(address account => uint256)) _balances;\n\n        mapping(address account => mapping(address operator => bool)) _operatorApprovals;\n\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n        string _uri;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;\n\n    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     */\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\n            } else {\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\n     * if it contains code at the moment of execution.\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) private {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-ERC1155Receiver implementer\n                    revert ERC1155InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/ERC20Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/cryptography/EIP712Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/introspection/ERC165Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/NoncesUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/PausableUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.0.2/utils/ReentrancyGuardUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/access/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/interfaces/IERC1271.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/interfaces/IERC1967.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/interfaces/IERC5267.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/ERC1967/ERC1967Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/ERC1967/ERC1967Utils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/transparent/ProxyAdmin.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.20;\n\nimport {ITransparentUpgradeableProxy} from \"./TransparentUpgradeableProxy.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`\n     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev Sets the initial owner who can perform upgrades.\n     */\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/proxy/transparent/TransparentUpgradeableProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\nimport {ERC1967Proxy} from \"../ERC1967/ERC1967Proxy.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {ProxyAdmin} from \"./ProxyAdmin.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address, bytes calldata) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it's set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable _admin;\n\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal virtual returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC1155/IERC1155.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC1155/IERC1155Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Arrays.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/cryptography/ECDSA.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/cryptography/MessageHashUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/abstract/SelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IPoseidonT3} from \"../interfaces/IPoseidonT3.sol\";\nimport {IIdentityVerificationHubV2} from \"../interfaces/IIdentityVerificationHubV2.sol\";\nimport {ISelfVerificationRoot} from \"../interfaces/ISelfVerificationRoot.sol\";\nimport {CircuitConstantsV2} from \"../constants/CircuitConstantsV2.sol\";\nimport {AttestationId} from \"../constants/AttestationId.sol\";\nimport {SelfUtils} from \"../libraries/SelfUtils.sol\";\nimport {Formatter} from \"../libraries/Formatter.sol\";\n\n/**\n * @title SelfVerificationRoot\n * @notice Abstract base contract to be integrated with self's verification infrastructure\n * @dev Provides base functionality for verifying and disclosing identity credentials\n * @author Self Team\n */\nabstract contract SelfVerificationRoot is ISelfVerificationRoot {\n    // ====================================================\n    // Constants\n    // ====================================================\n\n    /// @notice Contract version identifier used in verification process\n    /// @dev This version is included in the hub data for protocol compatibility\n    uint8 constant CONTRACT_VERSION = 2;\n\n    // ====================================================\n    // Storage Variables\n    // ====================================================\n\n    /// @notice The scope value that proofs must match\n    /// @dev Used to validate that submitted proofs match the expected scope\n    uint256 internal _scope;\n\n    /// @notice Reference to the identity verification hub V2 contract\n    /// @dev Immutable reference used for bytes-based proof verification\n    IIdentityVerificationHubV2 internal immutable _identityVerificationHubV2;\n\n    // ====================================================\n    // Errors\n    // ====================================================\n\n    /// @notice Error thrown when the data format is invalid\n    /// @dev Triggered when the provided bytes data doesn't have the expected format\n    error InvalidDataFormat();\n\n    /// @notice Error thrown when onVerificationSuccess is called by an unauthorized address\n    /// @dev Only the identity verification hub V2 contract can call onVerificationSuccess\n    error UnauthorizedCaller();\n\n    // ====================================================\n    // Events\n    // ====================================================\n\n    /**\n     * @notice Initializes the SelfVerificationRoot contract\n     * @dev Sets up the immutable reference to the hub contract and generates scope automatically\n     * @param identityVerificationHubV2Address The address of the Identity Verification Hub V2\n     * @param scopeSeed The scope seed string to be hashed with contract address to generate the scope\n     */\n    constructor(address identityVerificationHubV2Address, string memory scopeSeed) {\n        _identityVerificationHubV2 = IIdentityVerificationHubV2(identityVerificationHubV2Address);\n        _scope = _calculateScope(address(this), scopeSeed, _getPoseidonAddress());\n    }\n\n    /**\n     * @notice Returns the current scope value\n     * @dev Public view function to access the current scope setting\n     * @return The scope value that proofs must match\n     */\n    function scope() public view returns (uint256) {\n        return _scope;\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format proofPayload = | 32 bytes attestationId | proofData |\n     * @custom:data-format userContextData = | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format hubData = | 1 bytes contract version | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proofData |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) public {\n        // Minimum expected length for proofData: 32 bytes attestationId + proof data\n        if (proofPayload.length < 32) {\n            revert InvalidDataFormat();\n        }\n\n        // Minimum userDefinedData length: 32 (destChainId) + 32 (userIdentifier) + 0 (userDefinedData) = 64 bytes\n        if (userContextData.length < 64) {\n            revert InvalidDataFormat();\n        }\n\n        bytes32 attestationId;\n        assembly {\n            // Load attestationId from the beginning of proofData (first 32 bytes)\n            attestationId := calldataload(proofPayload.offset)\n        }\n\n        bytes32 destinationChainId = bytes32(userContextData[0:32]);\n        bytes32 userIdentifier = bytes32(userContextData[32:64]);\n        bytes memory userDefinedData = userContextData[64:];\n\n        bytes32 configId = getConfigId(destinationChainId, userIdentifier, userDefinedData);\n\n        // Hub data should be | 1 byte contractVersion | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proof data\n        bytes memory baseVerificationInput = abi.encodePacked(\n            // 1 byte contractVersion\n            CONTRACT_VERSION,\n            // 31 bytes buffer (all zeros)\n            bytes31(0),\n            // 32 bytes scope\n            _scope,\n            proofPayload\n        );\n\n        // Call hub V2 verification\n        _identityVerificationHubV2.verify(baseVerificationInput, bytes.concat(configId, userContextData));\n    }\n\n    /**\n     * @notice Callback function called upon successful verification by the hub contract\n     * @dev Only callable by the identity verification hub V2 contract for security\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:security Only the authorized hub contract can call this function\n     * @custom:flow This function decodes the output and calls the customizable verification hook\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) public {\n        // Only allow the identity verification hub V2 to call this function\n        if (msg.sender != address(_identityVerificationHubV2)) {\n            revert UnauthorizedCaller();\n        }\n\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory genericDiscloseOutput = abi.decode(\n            output,\n            (ISelfVerificationRoot.GenericDiscloseOutputV2)\n        );\n\n        // Call the customizable verification hook\n        customVerificationHook(genericDiscloseOutput, userData);\n    }\n\n    /**\n     * @notice Generates a configId for the user\n     * @dev This function should be overridden by the implementing contract to provide custom configId logic\n     * @param destinationChainId The destination chain ID\n     * @param userIdentifier The user identifier\n     * @param userDefinedData The user defined data\n     * @return The configId\n     */\n    function getConfigId(\n        bytes32 destinationChainId,\n        bytes32 userIdentifier,\n        bytes memory userDefinedData\n    ) public view virtual returns (bytes32) {\n        // Default implementation reverts; must be overridden in derived contract\n        revert(\"SelfVerificationRoot: getConfigId must be overridden\");\n    }\n\n    /**\n     * @notice Custom verification hook that can be overridden by implementing contracts\n     * @dev This function is called after successful verification and hub address validation\n     * @param output The verification output data from the hub containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:override Override this function in derived contracts to add custom verification logic\n     * @custom:security This function is only called after proper authentication by the hub contract\n     */\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal virtual {\n        // Default implementation is empty - override in derived contracts to add custom logic\n    }\n\n    /**\n     * @notice Gets the PoseidonT3 library address for the current chain\n     * @dev Returns hardcoded addresses of pre-deployed PoseidonT3 library on current chain\n     * @dev For local development networks, should create a setter function to set the scope manually\n     * @return The address of the PoseidonT3 library on this chain\n     */\n    function _getPoseidonAddress() internal view returns (address) {\n        uint256 chainId = block.chainid;\n\n        // Celo Mainnet\n        if (chainId == 42220) {\n            return 0xF134707a4C4a3a76b8410fC0294d620A7c341581;\n        }\n\n        // Celo Sepolia\n        if (chainId == 11142220) {\n            return 0x0a782f7F9f8Aac6E0bacAF3cD4aA292C3275C6f2;\n        }\n\n        // For local/development networks or other chains, return zero address\n        return address(0);\n    }\n\n    /**\n     * @notice Calculates scope from contract address, scope seed, and PoseidonT3 address\n     * @param contractAddress The contract address to hash\n     * @param scopeSeed The scope seed string\n     * @param poseidonT3Address The address of the PoseidonT3 library to use\n     * @return The calculated scope value\n     */\n    function _calculateScope(\n        address contractAddress,\n        string memory scopeSeed,\n        address poseidonT3Address\n    ) internal view returns (uint256) {\n        // Skip calculation if PoseidonT3 address is zero (local development)\n        if (poseidonT3Address == address(0)) {\n            return 0;\n        }\n\n        uint256 addressHash = _calculateAddressHashWithPoseidon(contractAddress, poseidonT3Address);\n        uint256 scopeSeedAsUint = SelfUtils.stringToBigInt(scopeSeed);\n        return IPoseidonT3(poseidonT3Address).hash([addressHash, scopeSeedAsUint]);\n    }\n\n    /**\n     * @notice Calculates hash of contract address using frontend-compatible chunking with specific PoseidonT3\n     * @dev Converts address to hex string, splits into 2 chunks (31+11), and hashes with provided PoseidonT3\n     * @param addr The contract address to hash\n     * @param poseidonT3Address The address of the PoseidonT3 library to use\n     * @return The hash result equivalent to frontend's endpointHash for addresses\n     */\n    function _calculateAddressHashWithPoseidon(\n        address addr,\n        address poseidonT3Address\n    ) internal view returns (uint256) {\n        // Convert address to hex string (42 chars: \"0x\" + 40 hex digits)\n        string memory addressString = SelfUtils.addressToHexString(addr);\n\n        // Split into exactly 2 chunks: 31 + 11 characters\n        // Chunk 1: characters 0-30 (31 chars)\n        // Chunk 2: characters 31-41 (11 chars)\n        uint256 chunk1BigInt = SelfUtils.stringToBigInt(Formatter.substring(addressString, 0, 31));\n        uint256 chunk2BigInt = SelfUtils.stringToBigInt(Formatter.substring(addressString, 31, 42));\n\n        return IPoseidonT3(poseidonT3Address).hash([chunk1BigInt, chunk2BigInt]);\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/constants/AttestationId.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title AttestationId Library\n * @notice This library provides attestation identifiers used across contracts.\n * @dev Currently, it contains the constant E_PASSPORT which represents the identifier\n * for an E-PASSPORT attestation computed as Poseidon(\"E-PASSPORT\").\n */\nlibrary AttestationId {\n    /**\n     * @notice Identifier for an E-PASSPORT attestation.\n     * @dev The identifier is computed based on the hash of \"E-PASSPORT\" using the Poseidon hash function.\n     * Here it is hardcoded as bytes32(uint256(1)) for demonstration purposes.\n     */\n    bytes32 constant E_PASSPORT = bytes32(uint256(1));\n    bytes32 constant EU_ID_CARD = bytes32(uint256(2));\n    bytes32 constant AADHAAR = bytes32(uint256(3));\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/constants/CircuitConstantsV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {AttestationId} from \"./AttestationId.sol\";\n\n/**\n * @title Circuit Constants Library\n * @notice This library defines constants representing indices used to access public signals\n *         of various circuits such as register, DSC, and VC/Disclose.\n * @dev These indices map directly to specific data fields in the corresponding circuits proofs.\n */\nlibrary CircuitConstantsV2 {\n    // ---------------------------\n    // Register Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the nullifier in the register circuit public signals.\n     */\n    uint256 constant REGISTER_NULLIFIER_INDEX = 0;\n\n    /**\n     * @notice Index to access the commitment in the register circuit public signals.\n     */\n    uint256 constant REGISTER_COMMITMENT_INDEX = 1;\n\n    /**\n     * @notice Index to access the Merkle root in the register circuit public signals.\n     */\n    uint256 constant REGISTER_MERKLE_ROOT_INDEX = 2;\n\n    // ---------------------------\n    // DSC Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the tree leaf in the DSC circuit public signals.\n     */\n    uint256 constant DSC_TREE_LEAF_INDEX = 0;\n\n    /**\n     * @notice Index to access the CSCA root in the DSC circuit public signals.\n     */\n    uint256 constant DSC_CSCA_ROOT_INDEX = 1;\n\n    // ---------------------------\n    // Aadhaar Circuit Constants\n    // ---------------------------\n    /**\n     * @notice Index to access the pubkey commitment in the Aadhaar circuit public signals.\n     */\n    uint256 constant AADHAAR_UIDAI_PUBKEY_COMMITMENT_INDEX = 0;\n    uint256 constant AADHAAR_NULLIFIER_INDEX = 1;\n    uint256 constant AADHAAR_COMMITMENT_INDEX = 2;\n    uint256 constant AADHAAR_TIMESTAMP_INDEX = 3;\n\n    // -------------------------------------\n    // VC and Disclose Circuit Constants\n    // -------------------------------------\n\n    /**\n     * @notice Structure containing circuit indices for a specific attestation type.\n     */\n    struct DiscloseIndices {\n        uint256 revealedDataPackedIndex;\n        uint256 forbiddenCountriesListPackedIndex;\n        uint256 nullifierIndex;\n        uint256 attestationIdIndex;\n        uint256 merkleRootIndex;\n        uint256 currentDateIndex;\n        uint256 namedobSmtRootIndex;\n        uint256 nameyobSmtRootIndex;\n        uint256 scopeIndex;\n        uint256 userIdentifierIndex;\n        uint256 passportNoSmtRootIndex;\n    }\n\n    /**\n     * @notice Returns the circuit indices for a given attestation type.\n     * @param attestationId The attestation identifier.\n     * @return indices The DiscloseIndices struct containing all relevant indices.\n     */\n    function getDiscloseIndices(bytes32 attestationId) internal pure returns (DiscloseIndices memory indices) {\n        if (attestationId == AttestationId.E_PASSPORT) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 3,\n                    nullifierIndex: 7,\n                    attestationIdIndex: 8,\n                    merkleRootIndex: 9,\n                    currentDateIndex: 10,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 16\n                });\n        } else if (attestationId == AttestationId.EU_ID_CARD) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 4,\n                    nullifierIndex: 8,\n                    attestationIdIndex: 9,\n                    merkleRootIndex: 10,\n                    currentDateIndex: 11,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 99\n                });\n        } else if (attestationId == AttestationId.AADHAAR) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 2,\n                    forbiddenCountriesListPackedIndex: 6,\n                    nullifierIndex: 0,\n                    attestationIdIndex: 10,\n                    merkleRootIndex: 16,\n                    currentDateIndex: 11,\n                    namedobSmtRootIndex: 14,\n                    nameyobSmtRootIndex: 15,\n                    scopeIndex: 17,\n                    userIdentifierIndex: 18,\n                    passportNoSmtRootIndex: 99\n                });\n        } else {\n            revert(\"Invalid attestation ID\");\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IDscCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title IDscCircuitVerifier\n * @notice Interface for verifying zero-knowledge proofs related to the DSC circuit.\n * @dev This interface defines the structure of a DSC circuit proof and exposes a function to verify such proofs.\n */\ninterface IDscCircuitVerifier {\n    /**\n     * @notice Represents a DSC circuit proof.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of two unsigned integers representing the public signals associated with the proof.\n     */\n    struct DscCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given DSC circuit zero-knowledge proof.\n     * @dev This function checks the validity of the provided DSC proof parameters.\n     * @param pA The 'a' component of the proof.\n     * @param pB The 'b' component of the proof.\n     * @param pC The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata pA,\n        uint256[2][2] calldata pB,\n        uint256[2] calldata pC,\n        uint256[2] calldata pubSignals\n    ) external view returns (bool);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IIdentityVerificationHubV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IRegisterCircuitVerifier} from \"./IRegisterCircuitVerifier.sol\";\nimport {IDscCircuitVerifier} from \"./IDscCircuitVerifier.sol\";\nimport {SelfStructs} from \"../libraries/SelfStructs.sol\";\n\n/**\n * @title IIdentityVerificationHubV2\n * @notice Interface for the Identity Verification Hub V2 for verifying zero-knowledge proofs.\n * @dev Defines all external and public functions from IdentityVerificationHubImplV2.\n */\ninterface IIdentityVerificationHubV2 {\n    // ====================================================\n    // External Functions\n    // ====================================================\n\n    /**\n     * @notice Registers a commitment using a register circuit proof.\n     * @dev Verifies the register circuit proof and then calls the Identity Registry to register the commitment.\n     * @param attestationId The attestation ID.\n     * @param registerCircuitVerifierId The identifier for the register circuit verifier to use.\n     * @param registerCircuitProof The register circuit proof data.\n     */\n    function registerCommitment(\n        bytes32 attestationId,\n        uint256 registerCircuitVerifierId,\n        IRegisterCircuitVerifier.RegisterCircuitProof memory registerCircuitProof\n    ) external;\n\n    /**\n     * @notice Registers a DSC key commitment using a DSC circuit proof.\n     * @dev Verifies the DSC proof and then calls the Identity Registry to register the dsc key commitment.\n     * @param attestationId The attestation ID.\n     * @param dscCircuitVerifierId The identifier for the DSC circuit verifier to use.\n     * @param dscCircuitProof The DSC circuit proof data.\n     */\n    function registerDscKeyCommitment(\n        bytes32 attestationId,\n        uint256 dscCircuitVerifierId,\n        IDscCircuitVerifier.DscCircuitProof memory dscCircuitProof\n    ) external;\n\n    /**\n     * @notice Sets verification config in V2 storage (owner only)\n     * @dev The configId is automatically generated from the config content using sha256(abi.encode(config))\n     * @param config The verification configuration\n     * @return configId The generated config ID\n     */\n    function setVerificationConfigV2(\n        SelfStructs.VerificationConfigV2 memory config\n    ) external returns (bytes32 configId);\n\n    /**\n     * @notice Main verification function with new structured input format\n     * @param baseVerificationInput The base verification input data\n     * @param userContextData The user context data\n     */\n    function verify(bytes calldata baseVerificationInput, bytes calldata userContextData) external;\n\n    /**\n     * @notice Updates the registry address.\n     * @param attestationId The attestation ID.\n     * @param registryAddress The new registry address.\n     */\n    function updateRegistry(bytes32 attestationId, address registryAddress) external;\n\n    /**\n     * @notice Updates the VC and Disclose circuit verifier address.\n     * @param attestationId The attestation ID.\n     * @param vcAndDiscloseCircuitVerifierAddress The new VC and Disclose circuit verifier address.\n     */\n    function updateVcAndDiscloseCircuit(bytes32 attestationId, address vcAndDiscloseCircuitVerifierAddress) external;\n\n    /**\n     * @notice Updates the register circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new register circuit verifier address.\n     */\n    function updateRegisterCircuitVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Updates the DSC circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new DSC circuit verifier address.\n     */\n    function updateDscVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Batch updates register circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new register circuit verifier addresses.\n     */\n    function batchUpdateRegisterCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    /**\n     * @notice Batch updates DSC circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new DSC circuit verifier addresses.\n     */\n    function batchUpdateDscCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    // ====================================================\n    // External View Functions\n    // ====================================================\n\n    /**\n     * @notice Returns the registry address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The registry address associated with the attestation ID.\n     */\n    function registry(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the disclose verifier address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The disclose verifier address associated with the attestation ID.\n     */\n    function discloseVerifier(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the register circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The register circuit verifier address associated with the attestation ID and type ID.\n     */\n    function registerCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the DSC circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The DSC circuit verifier address associated with the attestation ID and type ID.\n     */\n    function dscCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the merkle root timestamp for a given attestation ID and root.\n     * @param attestationId The attestation ID to query.\n     * @param root The merkle root to query.\n     * @return The merkle root timestamp associated with the attestation ID and root.\n     */\n    function rootTimestamp(bytes32 attestationId, uint256 root) external view returns (uint256);\n\n    /**\n     * @notice Returns the identity commitment merkle root for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The identity commitment merkle root associated with the attestation ID.\n     */\n    function getIdentityCommitmentMerkleRoot(bytes32 attestationId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a verification config exists\n     * @param configId The configuration identifier\n     * @return exists Whether the config exists\n     */\n    function verificationConfigV2Exists(bytes32 configId) external view returns (bool exists);\n\n    // ====================================================\n    // Public Functions\n    // ====================================================\n\n    /**\n     * @notice Generates a config ID from a verification config\n     * @param config The verification configuration\n     * @return The generated config ID (sha256 hash of encoded config)\n     */\n    function generateConfigId(SelfStructs.VerificationConfigV2 memory config) external pure returns (bytes32);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IPoseidonT3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title IPoseidonT3\n * @notice Interface for the PoseidonT3 library\n */\ninterface IPoseidonT3 {\n    function hash(uint256[2] memory inputs) external pure returns (uint256);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/IRegisterCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n/**\n * @title IRegisterCircuitVerifier\n * @notice Interface for verifying register circuit proofs.\n * @dev This interface defines the structure of a register circuit proof and exposes a function to verify such proofs.\n */\n\nstruct GenericProofStruct {\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n    uint256[] pubSignals;\n}\n\ninterface IRegisterCircuitVerifier {\n    /**\n     * @notice Represents a register circuit proof.\n     * @dev This structure encapsulates the required proof elements.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of three unsigned integers representing the public signals associated with the proof.\n     */\n    struct RegisterCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[3] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given register circuit proof.\n     * @dev This function checks the validity of the provided proof parameters.\n     * @param a The 'a' component of the proof.\n     * @param b The 'b' component of the proof.\n     * @param c The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return isValid A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[3] calldata pubSignals\n    ) external view returns (bool isValid);\n}\n\ninterface IAadhaarRegisterCircuitVerifier {\n    /**\n     * @notice Verifies a given register circuit proof.\n     * @dev This function checks the validity of the provided proof parameters.\n     * @param a The 'a' component of the proof.\n     * @param b The 'b' component of the proof.\n     * @param c The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return isValid A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint256[2] calldata a,\n        uint256[2][2] calldata b,\n        uint256[2] calldata c,\n        uint256[4] calldata pubSignals\n    ) external view returns (bool isValid);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/interfaces/ISelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title ISelfVerificationRoot\n * @notice Interface for self-verification infrastructure integration\n * @dev Provides base functionality for verifying and disclosing identity credentials\n */\ninterface ISelfVerificationRoot {\n    /**\n     * @notice Structure containing proof data for disclose circuits\n     * @dev Contains the proof elements required for zero-knowledge verification\n     * @param a First proof element\n     * @param b Second proof element (2x2 matrix)\n     * @param c Third proof element\n     * @param pubSignals Array of 21 public signals for the circuit\n     */\n    struct DiscloseCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[21] pubSignals;\n    }\n\n    /**\n     * @notice Structure containing verified identity disclosure output data\n     * @dev Contains all disclosed identity information after successful verification\n     * @param attestationId Unique identifier for the identity documents\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Unique nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed representation of forbidden countries list\n     * @param issuingState The state/country that issued the identity document\n     * @param name Array of name components\n     * @param idNumber The identity document number\n     * @param nationality The nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Expiry date of the identity document\n     * @param olderThan Verified age threshold (e.g., 18 for adult verification)\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) compliance flags\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes configId | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) external;\n\n    /**\n     * @notice Callback function called upon successful verification\n     * @dev Only the identity verification hub V2 contract should call this function\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) external;\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/Formatter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title Formatter Library\n * @notice A library providing utility functions to format names, dates, and encode data.\n */\nlibrary Formatter {\n    error InvalidDateLength();\n    error InvalidYearRange();\n    error InvalidMonthRange();\n    error InvalidDayRange();\n    error InvalidFieldElement();\n    error InvalidDateDigit();\n\n    uint256 constant MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /**\n     * @notice Formats a full name string into first name(s) and last name.\n     * @dev The input is expected to contain a last name, followed by a \"<<\" separator and then first name(s).\n     *      The returned array contains the first names at index 0 and the last name at index 1.\n     * @param input The input string structured as \"lastName<<firstName(s)\".\n     * @return names An array of two strings: [firstName(s), lastName].\n     */\n    function formatName(string memory input) internal pure returns (string[] memory) {\n        bytes memory inputBytes = bytes(input);\n        bytes memory firstNameBytes;\n        bytes memory lastNameBytes;\n        string[] memory names = new string[](2);\n\n        uint256 i = 0;\n        // Extract last name\n        while (i < inputBytes.length && inputBytes[i] != \"<\") {\n            lastNameBytes = abi.encodePacked(lastNameBytes, inputBytes[i]);\n            i++;\n        }\n\n        // Skip the separator \"<<\".\n        i += 2;\n\n        // Extract first names.\n        while (i < inputBytes.length) {\n            if (inputBytes[i] == \"<\") {\n                if (i + 1 < inputBytes.length && inputBytes[i + 1] == \"<\") {\n                    break;\n                }\n                firstNameBytes = abi.encodePacked(firstNameBytes, \" \");\n            } else {\n                firstNameBytes = abi.encodePacked(firstNameBytes, inputBytes[i]);\n            }\n            i++;\n        }\n\n        names[0] = string(firstNameBytes);\n        names[1] = string(lastNameBytes);\n        return names;\n    }\n\n    /**\n     * @notice Formats a compact date string into a human-readable date.\n     * @dev Expects the input date string to have exactly 6 characters in YYMMDD format.\n     *      Returns the date in \"DD-MM-YY\" format.\n     * @param date A string representing the date in YYMMDD format.\n     * @return A formatted date string in the format \"DD-MM-YY\".\n     */\n    function formatDate(string memory date) internal pure returns (string memory) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        string memory year = substring(date, 0, 2);\n        string memory month = substring(date, 2, 4);\n        string memory day = substring(date, 4, 6);\n\n        return string(abi.encodePacked(day, \"-\", month, \"-\", year));\n    }\n\n    /**\n     * @notice Formats a full year date string into a human-readable date.\n     * @dev Expects the input date string to have exactly 8 characters in YYYYMMDD format.\n     *      Returns the date in \"YYYY-MM-DD\" format.\n     * @param date A string representing the date in YYYYMMDD format.\n     * @return A formatted date string in the format \"YYYY-MM-DD\".\n     */\n    function formatDateFullYear(string memory date) internal pure returns (string memory) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 8) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[4] > \"1\" || (dateBytes[4] == \"1\" && dateBytes[5] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[6] > \"3\" || (dateBytes[6] == \"3\" && dateBytes[7] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        string memory year = substring(date, 0, 4);\n        string memory month = substring(date, 4, 6);\n        string memory day = substring(date, 6, 8);\n\n        return string(abi.encodePacked(day, \"-\", month, \"-\", year));\n    }\n\n    /**\n     * @notice Converts an ASCII numeral code to its corresponding unsigned integer.\n     * @dev The input must represent an ASCII code for digits (0-9), i.e. between 48 and 57.\n     *      Reverts with InvalidAsciiCode if the input is out of range.\n     * @param numAscii The ASCII code of a digit character.\n     * @return The numeric value (0-9) corresponding to the ASCII code.\n     */\n    function numAsciiToUint(uint256 numAscii) internal pure returns (uint256) {\n        return (numAscii - 48);\n    }\n\n    /**\n     * @notice Converts an array of three field elements into a bytes representation.\n     * @dev Each element is converted into a specific number of bytes: 31, 31, and 31 respectively.\n     * @param publicSignals An array of three unsigned integers representing field elements.\n     * @return bytesArray A bytes array of total length 93 that encodes the three field elements.\n     */\n    function fieldElementsToBytes(uint256[3] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[3] memory bytesCount = [31, 31, 31];\n        bytes memory bytesArray = new bytes(93);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    function fieldElementsToBytesIdCard(uint256[4] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD ||\n            publicSignals[3] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[4] memory bytesCount = [31, 31, 31, 1];\n        bytes memory bytesArray = new bytes(94);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    function fieldElementsToBytesAadhaar(uint256[4] memory publicSignals) internal pure returns (bytes memory) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (publicSignals[i] >= SNARK_SCALAR_FIELD) {\n                revert InvalidFieldElement();\n            }\n        }\n\n        uint8[4] memory bytesCount = [31, 31, 31, 26];\n        bytes memory bytesArray = new bytes(119);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n\n        return bytesArray;\n    }\n\n    /**\n     * @notice Extracts forbidden country codes from a packed uint256.\n     * @dev Each forbidden country is represented by 3 bytes in the packed data.\n     *      The function extracts up to MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH forbidden countries.\n     * @param publicSignals A packed uint256 containing encoded forbidden country data.\n     * @return forbiddenCountries An array of strings representing the forbidden country codes.\n     */\n    function extractForbiddenCountriesFromPacked(\n        uint256[4] memory publicSignals\n    ) internal pure returns (string[MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH] memory forbiddenCountries) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (publicSignals[i] >= SNARK_SCALAR_FIELD) {\n                revert InvalidFieldElement();\n            }\n        }\n\n        for (uint256 j = 0; j < MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH; j++) {\n            uint256 byteIndex = (j * 3) % 93;\n            uint256 index = j / 31;\n\n            if (byteIndex + 2 < 31) {\n                uint256 shift = byteIndex * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[index * 3] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 31) {\n                uint256 part0 = (publicSignals[0] >> (byteIndex * 8));\n                uint256 part1 = publicSignals[1] & 0x00ffff;\n                uint256 reversedPart1 = ((part1 & 0xff) << 8) | ((part1 & 0xff00) >> 8);\n                uint256 combined = reversedPart1 | (part0 << 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex + 2 < 62) {\n                uint256 byteIndexIn1 = byteIndex - 31;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[1] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 62) {\n                uint256 part0 = (publicSignals[1] >> ((byteIndex - 31) * 8)) & 0x00ffff;\n                uint256 reversedPart0 = ((part0 & 0xff) << 8) | ((part0 & 0xff00) >> 8);\n                uint256 part1 = publicSignals[2] & 0x0000ff;\n                uint256 combined = part1 | (reversedPart0 << 8);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex < 93) {\n                uint256 byteIndexIn1 = byteIndex - 62;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[2] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            }\n        }\n\n        return forbiddenCountries;\n    }\n\n    /**\n     * @notice Converts an array of 6 numerical values representing a date into a Unix timestamp.\n     * @dev Each element in the dateNum array is taken modulo 10, converted to its ASCII digit,\n     *      and concatenated to form a date string in YYMMDD format. This string is then converted\n     *      into a Unix timestamp using dateToUnixTimestamp.\n     * @param dateNum An array of 6 unsigned integers representing a date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the provided date.\n     */\n    function proofDateToUnixTimestamp(uint256[6] memory dateNum) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 6; i++) {\n            if (dateNum[i] > 9) {\n                revert InvalidDateDigit();\n            }\n        }\n        string memory date = \"\";\n        for (uint256 i = 0; i < 6; i++) {\n            date = string(abi.encodePacked(date, bytes1(uint8(48 + (dateNum[i] % 10)))));\n        }\n        uint256 currentTimestamp = dateToUnixTimestamp(date);\n        return currentTimestamp;\n    }\n\n    /**\n     * @notice Converts an array of 3 numerical values representing a date into a Unix timestamp.\n     * @dev The input is expected to be in the format [year, month, day] and is not padded with 0s.\n     * @param dateNum An array of 3 unsigned integers representing a date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the provided date.\n     */\n    function proofDateToUnixTimestampNumeric(uint256[3] memory dateNum) internal pure returns (uint256) {\n        if (dateNum[1] > 12 || dateNum[2] > 31) {\n            revert InvalidDateDigit();\n        }\n        return toTimestamp(dateNum[0], dateNum[1], dateNum[2]);\n    }\n\n    /**\n     * @notice Converts a date string in YYMMDD format into a Unix timestamp.\n     * @dev Parses the date string by extracting year, month, and day components using substring,\n     *      converts each component to an integer, and then computes the timestamp via toTimestamp.\n     *      Reverts if the input string is not exactly 6 characters long.\n     * @param date A 6-character string representing the date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the input date.\n     */\n    function dateToUnixTimestamp(string memory date) internal pure returns (uint256) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        uint256 year = parseDatePart(substring(date, 0, 2)) + 2000;\n        uint256 month = parseDatePart(substring(date, 2, 4));\n        uint256 day = parseDatePart(substring(date, 4, 6));\n\n        return toTimestamp(year, month, day);\n    }\n\n    /**\n     * @notice Extracts a substring from a given string.\n     * @dev Returns the substring from startIndex (inclusive) to endIndex (exclusive).\n     * @param str The input string.\n     * @param startIndex The starting index of the substring (inclusive).\n     * @param endIndex The ending index of the substring (exclusive).\n     * @return The resulting substring.\n     */\n    function substring(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n\n        return string(result);\n    }\n\n    /**\n     * @notice Parses a numeric string and returns its unsigned integer representation.\n     * @dev Assumes the input string contains only numeric characters.\n     * @param value The string representing a number.\n     * @return result The parsed unsigned integer.\n     */\n    function parseDatePart(string memory value) internal pure returns (uint256) {\n        bytes memory tempEmptyStringTest = bytes(value);\n        if (tempEmptyStringTest.length == 0) {\n            return 0;\n        }\n\n        uint256 digit;\n        uint256 result;\n        for (uint256 i = 0; i < tempEmptyStringTest.length; i++) {\n            digit = uint8(tempEmptyStringTest[i]) - 48;\n            result = result * 10 + digit;\n        }\n        return result;\n    }\n\n    /**\n     * @notice Converts a specific date into a Unix timestamp.\n     * @dev Calculates the timestamp by summing the number of days for years, months, and days since January 1, 1970.\n     *      Takes leap years into account during the calculation.\n     * @param year The full year (e.g., 2023).\n     * @param month The month (1-12).\n     * @param day The day of the month.\n     * @return timestamp The Unix timestamp corresponding to the given date.\n     */\n    function toTimestamp(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 timestamp) {\n        uint16 i;\n\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (month < 1 || month > 12) {\n            revert InvalidMonthRange();\n        }\n\n        // Year.\n        for (i = 1970; i < year; i++) {\n            if (isLeapYear(i)) {\n                timestamp += 366 days;\n            } else {\n                timestamp += 365 days;\n            }\n        }\n\n        // Month.\n        uint8[12] memory monthDayCounts;\n        monthDayCounts[0] = 31;\n        if (isLeapYear(year)) {\n            monthDayCounts[1] = 29;\n        } else {\n            monthDayCounts[1] = 28;\n        }\n        monthDayCounts[2] = 31;\n        monthDayCounts[3] = 30;\n        monthDayCounts[4] = 31;\n        monthDayCounts[5] = 30;\n        monthDayCounts[6] = 31;\n        monthDayCounts[7] = 31;\n        monthDayCounts[8] = 30;\n        monthDayCounts[9] = 31;\n        monthDayCounts[10] = 30;\n        monthDayCounts[11] = 31;\n\n        if (day < 1 || day > monthDayCounts[month - 1]) {\n            revert InvalidDayRange();\n        }\n\n        for (i = 1; i < month; i++) {\n            timestamp += monthDayCounts[i - 1] * 1 days;\n        }\n\n        // Day.\n        timestamp += (day - 1) * 1 days;\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Checks whether a given year is a leap year.\n     * @param year The year to check.\n     * @return True if the year is a leap year, otherwise false.\n     */\n    function isLeapYear(uint256 year) internal pure returns (bool) {\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (year % 4 != 0) {\n            return false;\n        } else if (year % 100 != 0) {\n            return true;\n        } else if (year % 400 != 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/SelfStructs.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title SelfStructs\n * @dev Library containing data structures for Self protocol identity verification\n * @notice Defines structs for passport verification, EU ID verification, and generic disclosure outputs\n */\nlibrary SelfStructs {\n    /**\n     * @dev Header structure for Hub input containing contract version and scope information\n     * @param contractVersion Version of the contract being used\n     * @param scope Scope identifier for the verification request\n     * @param attestationId Unique identifier for the attestation\n     */\n    struct HubInputHeader {\n        uint8 contractVersion;\n        uint256 scope;\n        bytes32 attestationId;\n    }\n\n    /**\n     * @dev Output structure for passport verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct PassportOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /**\n     * @dev Output structure for EU ID verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct EuIdOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /**\n     * @dev Output structure for Aadhaar verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     */\n    struct AadhaarOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /// @dev OFAC verification mode: Passport number only\n    uint256 constant passportNoOfac = 0;\n    /// @dev OFAC verification mode: Name and date of birth\n    uint256 constant nameAndDobOfac = 1;\n    /// @dev OFAC verification mode: Name and year of birth\n    uint256 constant nameAndYobOfac = 2;\n\n    /**\n     * @dev Generic disclosure output structure (Version 2) with detailed personal information\n     * @param attestationId Unique identifier for the attestation\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param issuingState Country or state that issued the document\n     * @param name Array of name components (first, middle, last names)\n     * @param idNumber Government-issued identification number\n     * @param nationality Nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Document expiration date in string format\n     * @param olderThan Minimum age verification result\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) verification results for different modes\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 1)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV1 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 2)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV2 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.3/contracts/libraries/SelfUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\nimport {SelfStructs} from \"./SelfStructs.sol\";\n\nlibrary SelfUtils {\n    struct UnformattedVerificationConfigV2 {\n        uint256 olderThan;\n        string[] forbiddenCountries;\n        bool ofacEnabled;\n    }\n\n    /**\n     * @dev Packs an array of forbidden countries into chunks suitable for circuit inputs\n     * @param forbiddenCountries Array of 3-character country codes\n     * @return output Array of 4 uint256 values containing packed country data\n     */\n    function packForbiddenCountriesList(\n        string[] memory forbiddenCountries\n    ) internal pure returns (uint256[4] memory output) {\n        uint256 MAX_BYTES_IN_FIELD = 31;\n        uint256 REQUIRED_CHUNKS = 4;\n\n        // Convert country codes to bytes array\n        bytes memory packedBytes;\n\n        // Validate and pack country codes\n        for (uint256 i = 0; i < forbiddenCountries.length; i++) {\n            bytes memory countryBytes = bytes(forbiddenCountries[i]);\n\n            // Validate country code length\n            require(countryBytes.length == 3, \"Invalid country code: must be exactly 3 characters long\");\n\n            // Append country code bytes\n            packedBytes = abi.encodePacked(packedBytes, countryBytes);\n        }\n\n        uint256 maxBytes = packedBytes.length;\n        uint256 packSize = MAX_BYTES_IN_FIELD;\n        uint256 numChunks = (maxBytes + packSize - 1) / packSize; // Ceiling division\n\n        // Pack bytes into chunks\n        for (uint256 i = 0; i < numChunks && i < REQUIRED_CHUNKS; i++) {\n            uint256 sum = 0;\n\n            for (uint256 j = 0; j < packSize; j++) {\n                uint256 idx = packSize * i + j;\n                if (idx < maxBytes) {\n                    uint256 value = uint256(uint8(packedBytes[idx]));\n                    uint256 shift = 8 * j;\n                    sum += value << shift;\n                }\n            }\n\n            output[i] = sum;\n        }\n\n        // Remaining elements are already initialized to 0\n        return output;\n    }\n\n    /**\n     * @dev Formats an unstructured verification configuration into the standardized circuit-compatible format\n     *\n     * This function transforms a simplified input structure into the complete verification configuration\n     * required by the verification config required by the hub.\n     *\n     * @notice Enabled Status Logic:\n     * - `olderThanEnabled`: Automatically set to `true` when `olderThan > 0`\n     * - `forbiddenCountriesEnabled`: Automatically set to `true` when `forbiddenCountries.length > 0`\n     * - `ofacEnabled`: Uses the provided boolean value, replicated across all 3 OFAC check levels\n     *\n     *\n     * @param unformattedVerificationConfigV2 The simplified input configuration containing:\n     *        - `olderThan`: Minimum age threshold (0 = disabled, >0 = enabled)\n     *        - `forbiddenCountries`: Array of 3-letter country codes (empty = disabled, non-empty = enabled)\n     *        - `ofacEnabled`: Boolean flag for all OFAC verification levels\n     *\n     * @return verificationConfigV2 The formatted configuration ready for circuit consumption with:\n     *         - Auto-computed enabled flags based on input values\n     *         - Packed forbidden countries list for efficient circuit processing\n     *         - Replicated OFAC settings across all verification levels\n     */\n    function formatVerificationConfigV2(\n        UnformattedVerificationConfigV2 memory unformattedVerificationConfigV2\n    ) internal pure returns (SelfStructs.VerificationConfigV2 memory verificationConfigV2) {\n        bool[3] memory ofacArray;\n        ofacArray[0] = unformattedVerificationConfigV2.ofacEnabled;\n        ofacArray[1] = unformattedVerificationConfigV2.ofacEnabled;\n        ofacArray[2] = unformattedVerificationConfigV2.ofacEnabled;\n\n        verificationConfigV2 = SelfStructs.VerificationConfigV2({\n            olderThanEnabled: unformattedVerificationConfigV2.olderThan > 0,\n            olderThan: unformattedVerificationConfigV2.olderThan,\n            forbiddenCountriesEnabled: unformattedVerificationConfigV2.forbiddenCountries.length > 0,\n            forbiddenCountriesListPacked: packForbiddenCountriesList(\n                unformattedVerificationConfigV2.forbiddenCountries\n            ),\n            ofacEnabled: ofacArray\n        });\n    }\n\n    /**\n     * @notice Convert string to BigInt using ASCII encoding\n     * @dev Converts each character to its ASCII value and packs them into a uint256\n     * @param str The input string (must be ASCII only, max 31 bytes)\n     * @return The resulting BigInt value\n     */\n    function stringToBigInt(string memory str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(str);\n        require(strBytes.length <= 31, \"String too long for BigInt conversion\");\n\n        uint256 result = 0;\n        for (uint256 i = 0; i < strBytes.length; i++) {\n            // Ensure ASCII only (0-127)\n            require(uint8(strBytes[i]) <= 127, \"Non-ASCII character detected\");\n            result = (result << 8) | uint256(uint8(strBytes[i]));\n        }\n        return result;\n    }\n\n    /**\n     * @notice Converts an address to its lowercase hex string representation\n     * @dev Produces a string like \"0x1234567890abcdef...\" (42 characters total)\n     * @param addr The address to convert\n     * @return The hex string representation of the address\n     */\n    function addressToHexString(address addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(str);\n    }\n}\n"
      },
      "project/contracts/badges/BadgeRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title BadgeRegistry\n * @notice ERC1155-based badge system for 4lph4Verse (UUPS upgradeable).\n *\n * Features\n * - Issue badges (ERC1155) with optional per-user expiry.\n * - Per-badge soulbound flag (non-transferable).\n * - App-gated mint/renew/revoke via roles (MINTER_ROLE / REVOKER_ROLE).\n * - Gating helpers: hasBadge, hasAny, tierOf.\n * - Tier model: badgeId -> tier (0..255); user tier = max active tier among held badges.\n *\n * Notes\n * - Amount is expected to be 1 per badge; ERC1155 semantics still supported.\n * - Set all badges soulbound=true to make registry fully non-transferable.\n * - Metadata: baseURI like ipfs://.../{id}.json (set via setURI).\n */\n\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\ncontract BadgeRegistry is\n    ERC1155Upgradeable,\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    AccessControlUpgradeable\n{\n    // ---- Roles ----\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); // Verse apps allowed to mint/renew\n    bytes32 public constant REVOKER_ROLE = keccak256(\"REVOKER_ROLE\"); // Can revoke (burn) badges\n\n    // ---- Storage ----\n    // badgeId => isSoulbound\n    mapping(uint256 => bool) public soulbound;\n\n    // badgeId => tier (0..255). 0 can mean \"no tier\"/decorative\n    mapping(uint256 => uint8) public badgeTier;\n\n    // user => badgeId => expiry timestamp (0 = no expiry)\n    mapping(address => mapping(uint256 => uint256)) public expiryOf;\n\n    // ---- Events ----\n    event BadgeMinted(\n        address indexed user,\n        uint256 indexed badgeId,\n        uint256 expiry\n    );\n    event BadgeRenewed(\n        address indexed user,\n        uint256 indexed badgeId,\n        uint256 newExpiry\n    );\n    event BadgeRevoked(address indexed user, uint256 indexed badgeId);\n    event SoulboundSet(uint256 indexed badgeId, bool isSoulbound);\n    event TierSet(uint256 indexed badgeId, uint8 tier);\n\n    // ---- Constructor (upgrade-safe) ----\n    constructor() {\n        _disableInitializers();\n    }\n\n    // ---- Init / Upgrade ----\n    function initialize(\n        address admin,\n        string memory baseURI\n    ) external initializer {\n        __ERC1155_init(baseURI);\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n    }\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(ADMIN_ROLE) {}\n\n    // ---- Admin ----\n    function setURI(string memory newuri) external onlyRole(ADMIN_ROLE) {\n        _setURI(newuri);\n        // Optional: emit EIP-4906 events offchain if needed\n    }\n\n    function setSoulbound(\n        uint256 badgeId,\n        bool isSoulbound\n    ) external onlyRole(ADMIN_ROLE) {\n        soulbound[badgeId] = isSoulbound;\n        emit SoulboundSet(badgeId, isSoulbound);\n    }\n\n    function setBadgeTier(\n        uint256 badgeId,\n        uint8 tier\n    ) external onlyRole(ADMIN_ROLE) {\n        badgeTier[badgeId] = tier;\n        emit TierSet(badgeId, tier);\n    }\n\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // ---- Mint / Renew / Revoke (Apps) ----\n    /// @notice Mint a badge to a user, optionally with expiry (0 = no expiry). Amount defaults to 1.\n    function mintBadge(\n        address user,\n        uint256 badgeId,\n        uint256 expiry\n    ) external whenNotPaused onlyRole(MINTER_ROLE) {\n        require(user != address(0), \"zero user\");\n        if (balanceOf(user, badgeId) == 0) {\n            _mint(user, badgeId, 1, \"\");\n        }\n        if (expiry != 0) {\n            require(expiry > block.timestamp, \"bad expiry\");\n            expiryOf[user][badgeId] = expiry;\n        } else {\n            expiryOf[user][badgeId] = 0; // perpetual\n        }\n        emit BadgeMinted(user, badgeId, expiryOf[user][badgeId]);\n    }\n\n    /// @notice Renew or set a new expiry for an existing badge (0 = perpetual).\n    function renewBadge(\n        address user,\n        uint256 badgeId,\n        uint256 newExpiry\n    ) external whenNotPaused onlyRole(MINTER_ROLE) {\n        require(balanceOf(user, badgeId) > 0, \"not holder\");\n        require(newExpiry == 0 || newExpiry > block.timestamp, \"bad expiry\");\n        expiryOf[user][badgeId] = newExpiry;\n        emit BadgeRenewed(user, badgeId, newExpiry);\n    }\n\n    /// @notice Revoke (burn) a user's badge.\n    function revokeBadge(\n        address user,\n        uint256 badgeId\n    ) external whenNotPaused onlyRole(REVOKER_ROLE) {\n        require(balanceOf(user, badgeId) > 0, \"not holder\");\n        expiryOf[user][badgeId] = 0;\n        _burn(user, badgeId, 1);\n        emit BadgeRevoked(user, badgeId);\n    }\n\n    /// @notice Users can self-burn their badge.\n    function selfBurn(uint256 badgeId) external whenNotPaused {\n        require(balanceOf(msg.sender, badgeId) > 0, \"not holder\");\n        expiryOf[msg.sender][badgeId] = 0;\n        _burn(msg.sender, badgeId, 1);\n        emit BadgeRevoked(msg.sender, badgeId);\n    }\n\n    // ---- Transfers (respect soulbound + expiry) ----\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public override {\n        require(!soulbound[id], \"soulbound\");\n        require(_isActive(from, id), \"expired\");\n        super.safeTransferFrom(from, to, id, amount, data);\n        // Note: expiry not propagated; recipient gets no expiry by default (0 = perpetual).\n    }\n\n    /// @notice One-to-many convenience for a single badge id (1 unit each).\n    function safeBatchTransferFrom(\n        address from,\n        address[] calldata tos,\n        uint256 id\n    ) external {\n        require(!soulbound[id], \"soulbound\");\n        require(_isActive(from, id), \"expired\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            super.safeTransferFrom(from, tos[i], id, 1, \"\");\n        }\n    }\n\n    // ---- Gating Helpers ----\n    /// @notice Whether a user currently holds an active (non-expired or perpetual) badge.\n    function hasBadge(\n        address user,\n        uint256 badgeId\n    ) public view returns (bool) {\n        if (balanceOf(user, badgeId) == 0) return false;\n        return _isActive(user, badgeId);\n    }\n\n    /// @notice True if user has any active badge among the provided ids.\n    function hasAny(\n        address user,\n        uint256[] calldata badgeIds\n    ) external view returns (bool) {\n        for (uint256 i = 0; i < badgeIds.length; i++) {\n            if (hasBadge(user, badgeIds[i])) return true;\n        }\n        return false;\n    }\n\n    /// @notice Compute user's tier as the max tier across active badges.\n    function tierOf(\n        address user,\n        uint256[] calldata considerIds\n    ) external view returns (uint8 tier) {\n        for (uint256 i = 0; i < considerIds.length; i++) {\n            uint256 id = considerIds[i];\n            if (hasBadge(user, id)) {\n                uint8 t = badgeTier[id];\n                if (t > tier) tier = t;\n            }\n        }\n    }\n\n    // ---- Internal ----\n    function _isActive(\n        address user,\n        uint256 badgeId\n    ) internal view returns (bool) {\n        uint256 exp = expiryOf[user][badgeId];\n        return exp == 0 || exp > block.timestamp;\n    }\n\n    // ---- Hooks ----\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal override whenNotPaused {\n        super._update(from, to, ids, values);\n\n        // block transfers for soulbound badges (mints/burns still allowed)\n        if (from != address(0) && to != address(0)) {\n            for (uint256 i = 0; i < ids.length; i++) {\n                require(!soulbound[ids[i]], \"soulbound\");\n                require(_isActive(from, ids[i]), \"expired\");\n            }\n        }\n    }\n\n    /// @inheritdoc ERC1155Upgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(AccessControlUpgradeable, ERC1155Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // ---- Storage gap ----\n    uint256[41] private __gap;\n}\n"
      },
      "project/contracts/core/AppRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title VerseAppRegistry\n * @notice Registry of all Verse apps (HireCore, VaultOfLove, LeaseVault, etc.)\n *\n * @dev\n * - UUPS Upgradeable, AccessControl-administered.\n * - Stores metadata, writer contract, score model contract, and weight in global score.\n * - Governance controlled (ADMIN_ROLE can add/update/disable apps).\n * - Future-proof: flexible weights, pluggable score models, upgradeable with storage gap.\n *\n * Typical consumers:\n * - ReputationHub: checks {active, writer} for a given appId to authorize writes; reads scoreModel.\n * - ScoreAggregator: iterates appIds, reads {active, weightBps, scoreModel} for weighted scoring.\n */\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@verse/contracts/interfaces/IVerseAppRegistry.sol\";\nimport \"@verse/contracts/interfaces/IScoreModel.sol\";\n\ncontract VerseAppRegistry is\n    Initializable,\n    UUPSUpgradeable,\n    AccessControlUpgradeable\n{\n    // ---------- Roles ----------\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // ---------- Types ----------\n    struct App {\n        string name; // human-readable name (\"HireCore\")\n        address writer; // contract allowed to write metrics in ReputationHub\n        address scoreModel; // contract implementing IScoreModel\n        uint16 weightBps; // weighting in global score (0-10000)\n        bool active; // app enabled/disabled\n    }\n\n    // ---------- Storage ----------\n    mapping(bytes32 => App) private apps; // appId => App\n    bytes32[] public appIds; // list of registered appIds (not pruned)\n\n    // ---------- Events ----------\n    event AppRegistered(\n        bytes32 indexed appId,\n        string name,\n        address writer,\n        address scoreModel,\n        uint16 weightBps\n    );\n    event AppUpdated(\n        bytes32 indexed appId,\n        address writer,\n        address scoreModel,\n        uint16 weightBps,\n        bool active\n    );\n    event AppRemoved(bytes32 indexed appId);\n    event AppNameUpdated(bytes32 indexed appId, string newName);\n    event AppWriterUpdated(bytes32 indexed appId, address writer);\n    event AppScoreModelUpdated(bytes32 indexed appId, address scoreModel);\n    event AppWeightUpdated(bytes32 indexed appId, uint16 weightBps);\n    event AppActiveUpdated(bytes32 indexed appId, bool active);\n\n    // ---------- Constructor (upgrade-safe) ----------\n    constructor() {\n        _disableInitializers();\n    }\n\n    // ---------- Init ----------\n    function initialize(address admin) external initializer {\n        require(admin != address(0), \"bad admin\");\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n    }\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(ADMIN_ROLE) {}\n\n    // ---------- Admin: Create / Update / Remove ----------\n    /**\n     * @notice Register a new appId with its config.\n     */\n    function registerApp(\n        bytes32 appId,\n        string calldata name,\n        address writer,\n        address scoreModel,\n        uint16 weightBps\n    ) external onlyRole(ADMIN_ROLE) {\n        require(appId != 0, \"bad appId\");\n        require(apps[appId].writer == address(0), \"already exists\");\n        require(weightBps <= 10_000, \"invalid weight\");\n\n        apps[appId] = App({\n            name: name,\n            writer: writer,\n            scoreModel: scoreModel,\n            weightBps: weightBps,\n            active: true\n        });\n        appIds.push(appId);\n\n        emit AppRegistered(appId, name, writer, scoreModel, weightBps);\n    }\n\n    /**\n     * @notice Bulk update (kept for convenience). Prefer granular setters to avoid accidental overwrites.\n     */\n    function updateApp(\n        bytes32 appId,\n        address writer,\n        address scoreModel,\n        uint16 weightBps,\n        bool active\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        require(weightBps <= 10_000, \"invalid weight\");\n\n        App storage app = apps[appId];\n        app.writer = writer;\n        app.scoreModel = scoreModel;\n        app.weightBps = weightBps;\n        app.active = active;\n\n        emit AppUpdated(appId, writer, scoreModel, weightBps, active);\n    }\n\n    /**\n     * @notice Remove app from mapping (appIds array is not pruned for gas reasons).\n     */\n    function removeApp(bytes32 appId) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        delete apps[appId];\n        emit AppRemoved(appId);\n    }\n\n    // ---------- Admin: Granular setters (safer upgrades) ----------\n    function setAppName(\n        bytes32 appId,\n        string calldata newName\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        apps[appId].name = newName;\n        emit AppNameUpdated(appId, newName);\n    }\n\n    function setAppWriter(\n        bytes32 appId,\n        address writer\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        apps[appId].writer = writer;\n        emit AppWriterUpdated(appId, writer);\n    }\n\n    function setAppScoreModel(\n        bytes32 appId,\n        address scoreModel\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        apps[appId].scoreModel = scoreModel;\n        emit AppScoreModelUpdated(appId, scoreModel);\n    }\n\n    function setAppWeight(\n        bytes32 appId,\n        uint16 weightBps\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        require(weightBps <= 10_000, \"invalid weight\");\n        apps[appId].weightBps = weightBps;\n        emit AppWeightUpdated(appId, weightBps);\n    }\n\n    function setAppActive(\n        bytes32 appId,\n        bool active\n    ) external onlyRole(ADMIN_ROLE) {\n        require(apps[appId].writer != address(0), \"not exists\");\n        apps[appId].active = active;\n        emit AppActiveUpdated(appId, active);\n    }\n\n    // ---------- Views (wiring helpers) ----------\n    function getApp(bytes32 appId) external view returns (App memory) {\n        return apps[appId];\n    }\n\n    function allAppIds() external view returns (bytes32[] memory) {\n        return appIds;\n    }\n\n    /// @notice Lightweight read for aggregators.\n    function appConfigOf(\n        bytes32 appId\n    )\n        external\n        view\n        returns (\n            address writer,\n            address scoreModel,\n            uint16 weightBps,\n            bool active\n        )\n    {\n        App storage a = apps[appId];\n        return (a.writer, a.scoreModel, a.weightBps, a.active);\n    }\n\n    /// @notice True if app exists and is active.\n    function isActive(bytes32 appId) external view returns (bool) {\n        return apps[appId].writer != address(0) && apps[appId].active;\n    }\n\n    /// @notice True if `candidate` is the registered writer for `appId`.\n    function isWriter(\n        bytes32 appId,\n        address candidate\n    ) external view returns (bool) {\n        return apps[appId].writer == candidate && apps[appId].active;\n    }\n\n    /// @notice Score + weight for a single app (0 if inactive or no model).\n    function computeAppScore(\n        bytes32 appId,\n        uint256 verseId\n    ) external view returns (uint256 rawScore, uint16 weightBps) {\n        App storage app = apps[appId];\n        if (!app.active || app.scoreModel == address(0)) return (0, 0);\n        rawScore = IScoreModel(app.scoreModel).scoreOf(verseId);\n        weightBps = app.weightBps;\n    }\n\n    // ---------- Storage gap ----------\n    uint256[45] private __gap;\n}\n"
      },
      "project/contracts/core/CoreFaucet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title CoreFaucet (Verse Ready)\n * @notice UUPS-upgradeable faucet for Alph4 CRE.\n *  - EIP-712 signed claims for gasless faucet access\n *  - Cooldown & nonce tracking\n *  - Configurable claim amount & admin controls\n */\ncontract CoreFaucet is\n    AccessControlUpgradeable,\n    UUPSUpgradeable,\n    EIP712Upgradeable\n{\n    using ECDSA for bytes32;\n\n    IERC20 public core;\n    uint256 public amountPerClaim;\n    uint256 public cooldownSeconds;\n    bool public paused;\n\n    mapping(address => uint256) public lastClaimTimestamp;\n    mapping(address => uint256) public nonces;\n\n    bytes32 public constant CLAIM_TYPEHASH =\n        keccak256(\"Claim(address to,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant FAUCET_ADMIN_ROLE = keccak256(\"FAUCET_ADMIN_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    event Claimed(address indexed who, uint256 amount, uint256 timestamp);\n    event AmountPerClaimUpdated(uint256 oldAmount, uint256 newAmount);\n    event CooldownUpdated(uint256 oldSeconds, uint256 newSeconds);\n    event PausedUpdated(bool oldPaused, bool newPaused);\n    event Drained(address to, uint256 amount);\n\n    /// -----------------------------------------------------------------------\n    /// Initializer (replaces constructor)\n    /// -----------------------------------------------------------------------\n    function initialize(\n        address admin,\n        address coreToken,\n        uint256 amountPerClaim_,\n        uint256 cooldownSeconds_\n    ) external initializer {\n        require(admin != address(0), \"bad admin\");\n        require(coreToken != address(0), \"bad token\");\n\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __EIP712_init(\"Alph4Verse Faucet\", \"1\");\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(FAUCET_ADMIN_ROLE, admin);\n        _grantRole(UPGRADER_ROLE, admin);\n\n        core = IERC20(coreToken);\n        amountPerClaim = amountPerClaim_;\n        cooldownSeconds = cooldownSeconds_;\n        paused = false;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Public: direct claim (EOA)\n    /// -----------------------------------------------------------------------\n    function claim() external {\n        require(!paused, \"paused\");\n        require(tx.origin == msg.sender, \"no contracts\");\n        require(\n            block.timestamp >= lastClaimTimestamp[msg.sender] + cooldownSeconds,\n            \"cooldown\"\n        );\n        _distribute(msg.sender);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Public: meta claim (EIP-712)\n    /// -----------------------------------------------------------------------\n    function claimWithSig(\n        address to,\n        uint256 nonce,\n        uint256 deadline,\n        bytes calldata signature\n    ) external {\n        require(!paused, \"paused\");\n        require(block.timestamp <= deadline, \"expired\");\n        require(nonce == nonces[to], \"bad nonce\");\n        require(\n            block.timestamp >= lastClaimTimestamp[to] + cooldownSeconds,\n            \"cooldown\"\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(CLAIM_TYPEHASH, to, nonce, deadline)\n        );\n        bytes32 digest = _hashTypedDataV4(structHash);\n        address signer = digest.recover(signature);\n        require(signer == to, \"invalid sig\");\n\n        nonces[to] = nonce + 1;\n        _distribute(to);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal: shared distribution logic\n    /// -----------------------------------------------------------------------\n    function _distribute(address to) internal {\n        uint256 balance = core.balanceOf(address(this));\n        require(balance >= amountPerClaim, \"empty\");\n        lastClaimTimestamp[to] = block.timestamp;\n        require(core.transfer(to, amountPerClaim), \"transfer failed\");\n        emit Claimed(to, amountPerClaim, block.timestamp);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Admin Controls\n    /// -----------------------------------------------------------------------\n    function setAmountPerClaim(\n        uint256 newAmount\n    ) external onlyRole(FAUCET_ADMIN_ROLE) {\n        emit AmountPerClaimUpdated(amountPerClaim, newAmount);\n        amountPerClaim = newAmount;\n    }\n\n    function setCooldownSeconds(\n        uint256 newSeconds\n    ) external onlyRole(FAUCET_ADMIN_ROLE) {\n        emit CooldownUpdated(cooldownSeconds, newSeconds);\n        cooldownSeconds = newSeconds;\n    }\n\n    function setPaused(bool newPaused) external onlyRole(FAUCET_ADMIN_ROLE) {\n        emit PausedUpdated(paused, newPaused);\n        paused = newPaused;\n    }\n\n    function drain(\n        address to,\n        uint256 amount\n    ) external onlyRole(FAUCET_ADMIN_ROLE) {\n        require(to != address(0), \"zero\");\n        require(core.transfer(to, amount), \"transfer failed\");\n        emit Drained(to, amount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Upgrade Auth\n    /// -----------------------------------------------------------------------\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(UPGRADER_ROLE) {}\n}\n"
      },
      "project/contracts/core/CoreToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title CoreToken (CRE)\n * @notice ERC20 with:\n *  - UUPS upgradeability\n *  - EIP-2612 permit approvals (gasless)\n *  - role-based mint/burn\n *  - transfer fee (bps) routed to treasury or burned\n *  - fee exemption list\n *  - adjustable treasury + fee mode\n *  - pausability for emergency controls\n *\n * Designed to be the native token of the 4lph4Verse.\n */\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\ncontract CoreToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    UUPSUpgradeable\n{\n    // -------------------- Roles --------------------\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\n    bytes32 public constant TREASURY_ROLE = keccak256(\"TREASURY_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    // -------------------- Fee State --------------------\n\n    /// @notice Transfer fee in basis points (e.g. 50 = 0.5%).\n    uint256 public feeBps;\n\n    /// @notice Treasury address that receives fees (when not burning).\n    address public treasury;\n\n    /// @notice If true, fees are burned instead of sent to treasury.\n    bool public feeBurns;\n\n    /// @notice Accounts that are exempt from paying (or receiving) fees.\n    mapping(address => bool) public isFeeExempt;\n\n    // -------------------- Events --------------------\n\n    event FeeBpsUpdated(uint256 oldBps, uint256 newBps);\n    event TreasuryUpdated(address oldTreasury, address newTreasury);\n    event FeeExemptUpdated(address account, bool exempt);\n    event FeeBurnModeUpdated(bool oldMode, bool newMode);\n    event FeeTaken(\n        address indexed from,\n        address indexed to,\n        uint256 fee,\n        bool burned\n    );\n\n    // -------------------- Initializer / Constructor --------------------\n\n    /// @dev Disable initializers on the implementation contract.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the CRE token behind a UUPS proxy.\n     * @param admin          Address that receives DEFAULT_ADMIN_ROLE and all core roles.\n     * @param treasury_      Initial treasury address for fee collection.\n     * @param initialSupply_ Initial supply (18 decimals) minted to admin.\n     * @param feeBps_        Initial fee in basis points (max 20% i.e. 2000 bps).\n     * @param feeBurns_      If true, fee is burned instead of going to treasury.\n     */\n    function initialize(\n        address admin,\n        address treasury_,\n        uint256 initialSupply_,\n        uint256 feeBps_,\n        bool feeBurns_\n    ) external initializer {\n        require(admin != address(0), \"CoreToken: bad admin\");\n        require(treasury_ != address(0), \"CoreToken: treasury required\");\n        require(feeBps_ <= 2000, \"CoreToken: fee too high\"); // max 20%\n\n        // Name + symbol define the EIP-712 domain for permit()\n        __ERC20_init(unicode\"Alph4 CRE\", unicode\"CRE\");\n        __ERC20Permit_init(unicode\"Alph4 CRE\");\n\n        __AccessControl_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n\n        // Roles\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(MINTER_ROLE, admin);\n        _grantRole(PAUSER_ROLE, admin);\n        _grantRole(FEE_MANAGER_ROLE, admin);\n        _grantRole(TREASURY_ROLE, admin);\n        _grantRole(UPGRADER_ROLE, admin);\n\n        // Fee config\n        feeBps = feeBps_;\n        treasury = treasury_;\n        feeBurns = feeBurns_;\n\n        // Exempt admin + treasury from fees by default\n        isFeeExempt[admin] = true;\n        isFeeExempt[treasury_] = true;\n\n        // Initial mint\n        if (initialSupply_ > 0) {\n            _mint(admin, initialSupply_);\n        }\n    }\n\n    // -------------------- Public / User functions --------------------\n\n    /**\n     * @notice Burn tokens from caller's balance.\n     */\n    function burn(uint256 amount) external {\n        _burn(_msgSender(), amount);\n    }\n\n    // -------------------- Admin: Mint / Burn --------------------\n\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    /**\n     * @notice Burn tokens from an arbitrary address (e.g. treasury ops).\n     * @dev Restricted to MINTER_ROLE to mirror privileged mint/burn rights.\n     */\n    function burnFrom(\n        address from,\n        uint256 amount\n    ) external onlyRole(MINTER_ROLE) {\n        _burn(from, amount);\n    }\n\n    // -------------------- Admin: Fees & Treasury --------------------\n\n    function setFeeBps(uint256 newBps) external onlyRole(FEE_MANAGER_ROLE) {\n        require(newBps <= 2000, \"CoreToken: fee too high\"); // max 20%\n        emit FeeBpsUpdated(feeBps, newBps);\n        feeBps = newBps;\n    }\n\n    function setTreasury(address newTreasury) external onlyRole(TREASURY_ROLE) {\n        require(newTreasury != address(0), \"CoreToken: zero treasury\");\n        emit TreasuryUpdated(treasury, newTreasury);\n        treasury = newTreasury;\n    }\n\n    function setFeeBurnMode(bool newMode) external onlyRole(FEE_MANAGER_ROLE) {\n        emit FeeBurnModeUpdated(feeBurns, newMode);\n        feeBurns = newMode;\n    }\n\n    function setFeeExempt(\n        address account,\n        bool exempt\n    ) external onlyRole(FEE_MANAGER_ROLE) {\n        isFeeExempt[account] = exempt;\n        emit FeeExemptUpdated(account, exempt);\n    }\n\n    // -------------------- Pause controls --------------------\n\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    // -------------------- Core transfer logic (with fee) --------------------\n\n    /**\n     * @dev Internal transfer hook with fee logic + pause enforcement.\n     *      Uses ERC20's new _update(...) pattern.\n     */\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override(ERC20Upgradeable) {\n        // When paused, block all transfers except mints/burns if you wish.\n        require(!paused(), \"CoreToken: token transfer while paused\");\n\n        // Mint or burn (from or to zero): no fee.\n        if (from == address(0) || to == address(0)) {\n            super._update(from, to, value);\n            return;\n        }\n\n        // No fee applied if feeBps is 0 or either side is exempt.\n        if (feeBps == 0 || isFeeExempt[from] || isFeeExempt[to]) {\n            super._update(from, to, value);\n            return;\n        }\n\n        uint256 fee = (value * feeBps) / 10_000;\n        uint256 afterFee = value - fee;\n\n        if (fee > 0) {\n            if (feeBurns) {\n                // Burn the fee\n                super._update(from, address(0), fee);\n                emit FeeTaken(from, address(0), fee, true);\n            } else {\n                // Send fee to treasury\n                super._update(from, treasury, fee);\n                emit FeeTaken(from, treasury, fee, false);\n            }\n        }\n\n        // Transfer the remainder to the recipient\n        super._update(from, to, afterFee);\n    }\n\n    // -------------------- UUPS upgrade auth --------------------\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(UPGRADER_ROLE) {}\n\n    // -------------------- ERC165 / AccessControl --------------------\n\n    function supportsInterface(\n        bytes4 iid\n    ) public view override(AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(iid);\n    }\n\n    // -------------------- Storage gap --------------------\n    uint256[44] private __gap;\n}\n"
      },
      "project/contracts/core/GuardianRecoveryModule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title GuardianRecoveryModule\n * @notice Handles guardians, freezes, and recovery flows for VerseProfile identities.\n *\n * This is a MODULE, not the core VerseProfile contract.\n * - VerseProfile remains the root identity registry.\n * - GuardianRecoveryModule manages:\n *   - Guardian sets (active + pending, with delays)\n *   - Freezing (soft/hard)\n *   - Recovery proposals and execution\n *   - Meta nonce epoch bumps (for invalidating signed meta tx)\n *\n * Design:\n * - Upgradeable via UUPS\n * - Governed via AccessControl (same pattern as VerseProfile)\n * - Meta-tx compatibility achieved via EIP-712 signatures (no ERC2771 here)\n */\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ninterface IVerseProfileMinimal {\n    function ownerOf(uint256 verseId) external view returns (address);\n\n    function hasProfile(address user) external view returns (bool);\n\n    function recoverySetOwner(uint256 verseId, address newOwner) external;\n}\n\ncontract GuardianRecoveryModule is\n    Initializable,\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    EIP712Upgradeable\n{\n    using ECDSA for bytes32;\n\n    // ------------------------------------------------------------------------\n    // Roles\n    // ------------------------------------------------------------------------\n\n    bytes32 public constant MODULE_ADMIN_ROLE = keccak256(\"MODULE_ADMIN_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    // ------------------------------------------------------------------------\n    // EIP-712: guardian approvals\n    // ------------------------------------------------------------------------\n\n    struct GuardianSignature {\n        address guardian;\n        bytes signature;\n    }\n\n    // action labels so guardians know exactly what they are signing\n    bytes32 private constant ACTION_HARD_FREEZE = keccak256(\"HARD_FREEZE\");\n    bytes32 private constant ACTION_UNFREEZE = keccak256(\"UNFREEZE\");\n    bytes32 private constant ACTION_RECOVERY_INIT = keccak256(\"RECOVERY_INIT\");\n    bytes32 private constant ACTION_RECOVERY_EXEC =\n        keccak256(\"RECOVERY_EXECUTE\");\n    bytes32 private constant ACTION_RECOVERY_CANCEL =\n        keccak256(\"RECOVERY_CANCEL\");\n\n    bytes32 private constant _GUARDIAN_APPROVAL_TYPEHASH =\n        keccak256(\n            \"GuardianApproval(uint256 verseId,bytes32 action,bytes32 paramsHash,uint64 guardianEpoch,uint256 recoveryNonce,uint256 deadline)\"\n        );\n\n    // ------------------------------------------------------------------------\n    // Constants\n    // ------------------------------------------------------------------------\n\n    // How long before guardian add/remove proposals can be applied (e.g. 7 days)\n    uint64 public constant GUARDIAN_DELAY = 7 days;\n\n    // How long between recovery initiation and execution (e.g. 72 hours)\n    uint64 public constant RECOVERY_DELAY = 72 hours;\n\n    // Soft freeze duration (e.g. 24 hours)\n    uint64 public constant SOFT_FREEZE_DURATION = 24 hours;\n\n    // Minimum number of active guardians required (quorum floor)\n    uint8 public constant MIN_GUARDIANS = 2;\n\n    // ------------------------------------------------------------------------\n    // Structs\n    // ------------------------------------------------------------------------\n\n    struct GuardianSet {\n        address[] active; // current guardians\n        uint8 threshold; // signatures required for actions (>= 1, <= active.length)\n        uint64 epoch; // incremented when guardian set changes (for signature domains)\n    }\n\n    struct GuardianChange {\n        address[] pending; // proposed full new set\n        uint8 newThreshold; // proposed threshold\n        uint64 applyAfter; // timestamp when change can be applied\n        uint64 expiresAt; // optional expiry for the proposal\n    }\n\n    struct RecoveryState {\n        address pendingNewOwner; // proposed new owner\n        uint64 eta; // earliest time when executeRecovery is allowed\n        uint256 nonce; // incremented for each new recovery attempt\n        bool active; // whether a recovery is currently in progress\n    }\n\n    // ------------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------------\n\n    // VerseProfile contract\n    IVerseProfileMinimal public verseProfile;\n\n    // Per-verseId guardian data\n    mapping(uint256 => GuardianSet) public guardians; // verseId => guardian set\n    mapping(uint256 => GuardianChange) public guardianOps; // verseId => pending change\n\n    // Freeze state\n    mapping(uint256 => uint64) public softFreezeUntil; // verseId => timestamp\n    mapping(uint256 => bool) public hardFrozen; // verseId => hard freeze flag\n\n    // Recovery state\n    mapping(uint256 => RecoveryState) public recovery; // verseId => recovery info\n\n    // Meta-tx safety: epoch per verseId (for EIP-712 domain separation / invalidation)\n    mapping(uint256 => uint64) public metaNonceEpoch; // verseId => epoch\n\n    // ------------------------------------------------------------------------\n    // Events\n    // ------------------------------------------------------------------------\n\n    // Guardians\n    event GuardiansProposed(\n        uint256 indexed verseId,\n        address[] newGuardians,\n        uint8 newThreshold,\n        uint64 applyAfter,\n        uint64 expiresAt\n    );\n\n    event GuardiansApplied(\n        uint256 indexed verseId,\n        address[] guardians,\n        uint8 threshold,\n        uint64 newEpoch\n    );\n\n    // Freezes\n    event SoftFrozen(uint256 indexed verseId, uint64 until);\n    event HardFrozen(uint256 indexed verseId);\n    event Unfrozen(uint256 indexed verseId);\n\n    // Recovery\n    event RecoveryInitiated(\n        uint256 indexed verseId,\n        address indexed pendingNewOwner,\n        uint64 eta,\n        uint256 recoveryNonce\n    );\n    event RecoveryCanceled(uint256 indexed verseId, uint256 recoveryNonce);\n    event RecoveryExecuted(\n        uint256 indexed verseId,\n        address indexed oldOwner,\n        address indexed newOwner,\n        uint256 recoveryNonce\n    );\n\n    // Meta nonce epoch\n    event MetaNonceEpochBumped(uint256 indexed verseId, uint64 newEpoch);\n\n    // ------------------------------------------------------------------------\n    // Views\n    // ------------------------------------------------------------------------\n\n    function getGuardians(\n        uint256 verseId\n    )\n        external\n        view\n        returns (address[] memory active, uint8 threshold, uint64 epoch)\n    {\n        GuardianSet storage set = guardians[verseId];\n        return (set.active, set.threshold, set.epoch);\n    }\n\n    // ------------------------------------------------------------------------\n    // Freeze views\n    // ------------------------------------------------------------------------\n\n    function isFrozen(uint256 verseId) public view returns (bool) {\n        // soft freeze active?\n        if (softFreezeUntil[verseId] > block.timestamp) {\n            return true;\n        }\n        // hard freeze flag\n        if (hardFrozen[verseId]) {\n            return true;\n        }\n        return false;\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor (implementation) + Initialize (proxy)\n    // ------------------------------------------------------------------------\n\n    /// @dev Disable initializers on the implementation contract.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the module behind a UUPS proxy.\n     * @param admin Address that receives DEFAULT_ADMIN_ROLE, MODULE_ADMIN_ROLE, and UPGRADER_ROLE\n     * @param verseProfileAddress Address of the VerseProfile core contract\n     */\n    function initialize(\n        address admin,\n        address verseProfileAddress\n    ) external initializer {\n        require(admin != address(0), \"GuardianModule: bad admin\");\n        require(\n            verseProfileAddress != address(0),\n            \"GuardianModule: zero verseProfile\"\n        );\n\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        __AccessControl_init();\n        __EIP712_init(\"GuardianRecoveryModule\", \"0.1\");\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(MODULE_ADMIN_ROLE, admin);\n        _grantRole(UPGRADER_ROLE, admin);\n\n        verseProfile = IVerseProfileMinimal(verseProfileAddress);\n    }\n\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n\n    modifier onlyProfileOwner(uint256 verseId) {\n        require(\n            verseProfile.ownerOf(verseId) == _msgSender(),\n            \"GuardianModule: not owner\"\n        );\n        _;\n    }\n\n    modifier notHardFrozen(uint256 verseId) {\n        require(!hardFrozen[verseId], \"GuardianModule: profile hard frozen\");\n        _;\n    }\n    modifier notFrozen(uint256 verseId) {\n        // soft or hard freeze both block this\n        if (softFreezeUntil[verseId] > block.timestamp) {\n            revert(\"GuardianModule: soft frozen\");\n        }\n        if (hardFrozen[verseId]) {\n            revert(\"GuardianModule: hard frozen\");\n        }\n        _;\n    }\n\n    // ------------------------------------------------------------------------\n    // Guardian configuration: propose + apply\n    // ------------------------------------------------------------------------\n\n    /**\n     * @notice Propose a new full guardian set for a VerseID.\n     *         Does NOT take effect immediately. Must be applied after GUARDIAN_DELAY.\n     *\n     * @dev Only the current VerseProfile owner can propose a change.\n     */\n    function proposeGuardians(\n        uint256 verseId,\n        address[] calldata newGuardians,\n        uint8 newThreshold\n    ) external onlyProfileOwner(verseId) notHardFrozen(verseId) whenNotPaused {\n        uint256 len = newGuardians.length;\n        require(len >= MIN_GUARDIANS, \"GuardianModule: too few guardians\");\n        require(\n            newThreshold > 0 && newThreshold <= len,\n            \"GuardianModule: bad threshold\"\n        );\n\n        // Validate non-zero & no duplicates (O(n^2), but guardian sets are small)\n        for (uint256 i; i < len; ++i) {\n            address g = newGuardians[i];\n            require(g != address(0), \"GuardianModule: zero guardian\");\n            for (uint256 j = i + 1; j < len; ++j) {\n                require(\n                    newGuardians[j] != g,\n                    \"GuardianModule: duplicate guardian\"\n                );\n            }\n        }\n\n        uint64 applyAfter = uint64(block.timestamp + GUARDIAN_DELAY);\n        // Optional expiry: proposal is only valid for another GUARDIAN_DELAY after it becomes applyable\n        uint64 expiresAt = applyAfter + GUARDIAN_DELAY;\n\n        GuardianChange storage op = guardianOps[verseId];\n\n        // Reset and store the new proposal\n        delete op.pending;\n        for (uint256 i; i < len; ++i) {\n            op.pending.push(newGuardians[i]);\n        }\n\n        op.newThreshold = newThreshold;\n        op.applyAfter = applyAfter;\n        op.expiresAt = expiresAt;\n\n        emit GuardiansProposed(\n            verseId,\n            newGuardians,\n            newThreshold,\n            applyAfter,\n            expiresAt\n        );\n    }\n\n    // ------------------------------------------------------------------------\n    // Pause Controls (optional, module-level)\n    // ------------------------------------------------------------------------\n\n    function pause() external onlyRole(MODULE_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(MODULE_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // ------------------------------------------------------------------------\n    // UUPS upgrade authorization\n    // ------------------------------------------------------------------------\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(UPGRADER_ROLE) {}\n\n    // ------------------------------------------------------------------------\n    // STEP 1C COMPLETE: upgradeable, role-based, Verse-style skeleton.\n    // ------------------------------------------------------------------------\n    // Next steps (we'll add incrementally):\n    // - Functions to propose/apply guardian sets (with delays + epoch bumps)\n    // - Functions to soft/hard freeze and unfreeze\n    // - Functions to initiate/cancel/execute recovery\n    // - Functions to bump metaNonceEpoch\n    // - Signature verification (EIP-712) for guardian approvals\n    // - Restricted call into VerseProfile to change owner on successful recovery\n\n    /**\n     * @notice Apply a previously proposed guardian set after the delay has passed.\n     * @dev Anyone can call this once the proposal is mature and not expired.\n     */\n    function applyGuardians(\n        uint256 verseId\n    ) external notHardFrozen(verseId) whenNotPaused {\n        GuardianChange storage op = guardianOps[verseId];\n        require(op.applyAfter != 0, \"GuardianModule: no pending change\");\n        require(block.timestamp >= op.applyAfter, \"GuardianModule: too early\");\n        require(\n            op.expiresAt == 0 || block.timestamp <= op.expiresAt,\n            \"GuardianModule: proposal expired\"\n        );\n\n        uint256 len = op.pending.length;\n        require(len >= MIN_GUARDIANS, \"GuardianModule: too few guardians\");\n        require(\n            op.newThreshold > 0 && op.newThreshold <= len,\n            \"GuardianModule: bad threshold\"\n        );\n\n        GuardianSet storage set = guardians[verseId];\n\n        // Replace active set\n        delete set.active;\n        for (uint256 i; i < len; ++i) {\n            set.active.push(op.pending[i]);\n        }\n        set.threshold = op.newThreshold;\n        set.epoch += 1; // bump epoch so old guardian signatures can't be replayed\n\n        // Keep metaNonceEpoch in sync with guardian epoch (optional, but nice)\n        metaNonceEpoch[verseId] = set.epoch;\n\n        uint64 newEpoch = set.epoch;\n\n        // Clear pending proposal\n        delete guardianOps[verseId];\n\n        emit GuardiansApplied(verseId, set.active, set.threshold, newEpoch);\n    }\n\n    // ------------------------------------------------------------------------\n    // Internal: guardian helpers\n    // ------------------------------------------------------------------------\n\n    function _isGuardian(\n        uint256 verseId,\n        address account\n    ) internal view returns (bool) {\n        GuardianSet storage set = guardians[verseId];\n        uint256 len = set.active.length;\n        for (uint256 i; i < len; ++i) {\n            if (set.active[i] == account) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Verify guardian EIP-712 signatures for a specific action.\n     * @param verseId Verse profile ID the action targets\n     * @param action  One of the ACTION_* constants\n     * @param paramsHash keccak256-encoded extra params (e.g. newOwner)\n     * @param recoveryNonce  Recovery nonce (0 for non-recovery actions)\n     * @param deadline  Timestamp after which signatures are invalid\n     * @param approvals  Guardians + their signatures\n     * @return validCount  Number of valid, unique guardian approvals\n     */\n    function _verifyGuardianApprovalsTyped(\n        uint256 verseId,\n        bytes32 action,\n        bytes32 paramsHash,\n        uint256 recoveryNonce,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) internal view returns (uint256 validCount) {\n        require(\n            block.timestamp <= deadline,\n            \"GuardianModule: approvals expired\"\n        );\n\n        GuardianSet storage set = guardians[verseId];\n        uint256 lenSet = set.active.length;\n        require(\n            lenSet >= MIN_GUARDIANS,\n            \"GuardianModule: no guardians configured\"\n        );\n\n        // Common digest all guardians sign\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _GUARDIAN_APPROVAL_TYPEHASH,\n                verseId,\n                action,\n                paramsHash,\n                set.epoch,\n                recoveryNonce,\n                deadline\n            )\n        );\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        // Track which guardians we've already counted to avoid double-count\n        bool[] memory seen = new bool[](lenSet);\n\n        for (uint256 i; i < approvals.length; ++i) {\n            address claimedGuardian = approvals[i].guardian;\n            // Recover signer from signature\n            address signer = digest.recover(approvals[i].signature);\n            if (signer != claimedGuardian) continue;\n\n            // Check that this address is an active guardian and not counted yet\n            for (uint256 j; j < lenSet; ++j) {\n                if (set.active[j] == claimedGuardian && !seen[j]) {\n                    seen[j] = true;\n                    ++validCount;\n                    break;\n                }\n            }\n        }\n    }\n\n    function _requireGuardianThreshold(\n        uint256 verseId,\n        bytes32 action,\n        bytes32 paramsHash,\n        uint256 recoveryNonce,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) internal view {\n        uint256 count = _verifyGuardianApprovalsTyped(\n            verseId,\n            action,\n            paramsHash,\n            recoveryNonce,\n            deadline,\n            approvals\n        );\n        require(\n            count >= guardians[verseId].threshold,\n            \"GuardianModule: insufficient guardian approvals\"\n        );\n    }\n\n    modifier onlyGuardian(uint256 verseId) {\n        require(\n            _isGuardian(verseId, _msgSender()),\n            \"GuardianModule: not guardian\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Start a recovery flow proposing a new owner.\n     * @dev Requires guardian quorum approval. Starts RECOVERY_DELAY timer.\n     */\n    function initiateRecovery(\n        uint256 verseId,\n        address newOwner,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) external whenNotPaused notHardFrozen(verseId) {\n        require(newOwner != address(0), \"GuardianModule: zero new owner\");\n\n        RecoveryState storage r = recovery[verseId];\n        require(!r.active, \"GuardianModule: recovery already active\");\n\n        // Next recovery nonce (we sign over this)\n        uint256 nextNonce = r.nonce + 1;\n\n        bytes32 paramsHash = keccak256(abi.encodePacked(newOwner));\n\n        _requireGuardianThreshold(\n            verseId,\n            ACTION_RECOVERY_INIT,\n            paramsHash,\n            nextNonce,\n            deadline,\n            approvals\n        );\n\n        // Freeze during recovery\n        softFreezeUntil[verseId] = uint64(\n            block.timestamp + SOFT_FREEZE_DURATION\n        );\n\n        r.pendingNewOwner = newOwner;\n        r.eta = uint64(block.timestamp + RECOVERY_DELAY);\n        r.nonce = nextNonce;\n        r.active = true;\n\n        emit RecoveryInitiated(verseId, newOwner, r.eta, r.nonce);\n    }\n\n    /**\n     * @notice Complete a recovery after delay has passed.\n     * @dev Requires guardian quorum. Calls VerseProfile to set new owner.\n     */\n    function executeRecovery(\n        uint256 verseId,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) external whenNotPaused notFrozen(verseId) {\n        RecoveryState storage r = recovery[verseId];\n        require(r.active, \"GuardianModule: no active recovery\");\n        require(\n            block.timestamp >= r.eta,\n            \"GuardianModule: recovery delay not over\"\n        );\n\n        bytes32 paramsHash = keccak256(abi.encodePacked(r.pendingNewOwner));\n\n        _requireGuardianThreshold(\n            verseId,\n            ACTION_RECOVERY_EXEC,\n            paramsHash,\n            r.nonce,\n            deadline,\n            approvals\n        );\n\n        address oldOwner = verseProfile.ownerOf(verseId);\n        address newOwner = r.pendingNewOwner;\n        require(newOwner != address(0), \"GuardianModule: no pending owner\");\n\n        verseProfile.recoverySetOwner(verseId, newOwner);\n\n        r.active = false;\n        r.pendingNewOwner = address(0);\n\n        emit RecoveryExecuted(verseId, oldOwner, newOwner, r.nonce);\n\n        // Unfreeze after successful recovery\n        hardFrozen[verseId] = false;\n        softFreezeUntil[verseId] = 0;\n        emit Unfrozen(verseId);\n    }\n\n    function bumpMetaNonceEpoch(\n        uint256 verseId\n    ) external onlyProfileOwner(verseId) {\n        metaNonceEpoch[verseId]++;\n        emit MetaNonceEpochBumped(verseId, metaNonceEpoch[verseId]);\n    }\n\n    // ------------------------------------------------------------------------\n    // Freeze controls\n    // ------------------------------------------------------------------------\n\n    /**\n     * @notice Soft-freeze a profile for a limited time.\n     * @dev Any active guardian can call this.\n     *      Soft freeze auto-expires after SOFT_FREEZE_DURATION.\n     */\n    function softFreeze(\n        uint256 verseId\n    ) external onlyGuardian(verseId) whenNotPaused {\n        uint64 until = uint64(block.timestamp + SOFT_FREEZE_DURATION);\n\n        // If there is already a soft freeze further in the future, don't shorten it.\n        if (until > softFreezeUntil[verseId]) {\n            softFreezeUntil[verseId] = until;\n            emit SoftFrozen(verseId, until);\n        }\n    }\n\n    /**\n     * @notice Permanently freeze a profile until unfreezed by guardian quorum.\n     * @dev Requires threshold approval. Emits HardFrozen event.\n     */\n    function hardFreeze(\n        uint256 verseId,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) external whenNotPaused {\n        require(!hardFrozen[verseId], \"GuardianModule: already hard frozen\");\n        _requireGuardianThreshold(\n            verseId,\n            ACTION_HARD_FREEZE,\n            bytes32(0), // no extra params\n            0, // no recovery nonce involved\n            deadline,\n            approvals\n        );\n\n        hardFrozen[verseId] = true;\n        emit HardFrozen(verseId);\n    }\n\n    /**\n     * @notice Lift a hard freeze after investigation.\n     * @dev Requires guardian threshold approvals.\n     */\n    function unfreeze(\n        uint256 verseId,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) external whenNotPaused {\n        require(hardFrozen[verseId], \"GuardianModule: not hard frozen\");\n\n        _requireGuardianThreshold(\n            verseId,\n            ACTION_UNFREEZE,\n            bytes32(0),\n            0,\n            deadline,\n            approvals\n        );\n\n        hardFrozen[verseId] = false;\n        softFreezeUntil[verseId] = 0;\n        emit Unfrozen(verseId);\n    }\n\n    function cancelRecovery(\n        uint256 verseId,\n        uint256 deadline,\n        GuardianSignature[] calldata approvals\n    ) external whenNotPaused {\n        RecoveryState storage r = recovery[verseId];\n        require(r.active, \"GuardianModule: no active recovery\");\n\n        address owner = verseProfile.ownerOf(verseId);\n        bool byOwner = owner == _msgSender();\n        bool byGuardians = false;\n\n        if (!byOwner) {\n            bytes32 paramsHash = keccak256(abi.encodePacked(r.pendingNewOwner));\n            _requireGuardianThreshold(\n                verseId,\n                ACTION_RECOVERY_CANCEL,\n                paramsHash,\n                r.nonce,\n                deadline,\n                approvals\n            );\n            byGuardians = true;\n        }\n\n        require(byOwner || byGuardians, \"GuardianModule: no cancel authority\");\n\n        r.active = false;\n        emit RecoveryCanceled(verseId, r.nonce);\n    }\n\n    /**\n     * @notice Clear both soft and hard freeze state for a profile.\n     * @dev Callable by module admin. Use with care.\n     */\n    function forceUnfreeze(\n        uint256 verseId\n    ) external onlyRole(MODULE_ADMIN_ROLE) {\n        softFreezeUntil[verseId] = 0;\n        hardFrozen[verseId] = false;\n        emit Unfrozen(verseId);\n    }\n\n    function supportsInterface(\n        bytes4 iid\n    ) public view override(AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(iid);\n    }\n\n    // ------------------------------------------------------------------------\n    // Storage gap for future upgrades\n    // ------------------------------------------------------------------------\n    uint256[44] private __gap;\n}\n"
      },
      "project/contracts/core/HumanVerificationModule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/*\n HumanVerificationModule.sol\n\n - Inherits SelfVerificationRoot from @selfxyz/contracts (your installed package)\n - On successful Self verification, marks subject as human-verified and\n   writes result back to a VerseProfile contract via a minimal interface.\n   When a user is verified, His or her profile can be recovered during compromise by \n   re-verifying in the selfRecovery module without needing a guardian\n\n*/\n\nimport \"@selfxyz/contracts/contracts/abstract/SelfVerificationRoot.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SelfUtils} from \"@selfxyz/contracts/contracts/libraries/SelfUtils.sol\";\nimport {SelfStructs} from \"@selfxyz/contracts/contracts/libraries/SelfStructs.sol\";\nimport {IIdentityVerificationHubV2} from \"@selfxyz/contracts/contracts/interfaces/IIdentityVerificationHubV2.sol\";\nimport {IVerseProfile} from \"../interfaces/IVerseProfile.sol\";\n\ncontract HumanVerificationModule is AccessControl, SelfVerificationRoot {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    /// @notice reference to VerseProfile contract (single source of truth)\n    address public verseProfile;\n\n    /// @notice config id returned by getConfigId (optional)\n    bytes32 public verificationConfigId;\n\n    /// @notice  scope seed recorded locally (for SDK/frontend)\n    string public scopeSeed = \"proof-of-alpha\";\n\n    /// @notice mapping to track when an address was verified\n    mapping(address => uint256) public verifiedAt;\n\n    /// @notice events\n    event HumanVerified(\n        address indexed subject,\n        bytes32 dochash,\n        uint256 timestamp\n    );\n\n    event HumanRevoked(\n        address indexed subject,\n        address operator,\n        uint256 timestamp\n    );\n    event VerificationConfigIdUpdated(bytes32 configId);\n    event VerseProfileUpdated(address indexed verseProfile);\n\n    error ZeroAddress();\n    error AlreadyVerified(address who);\n    error NotVerified(address who);\n\n    constructor(\n        address identityVerificationHub\n    ) SelfVerificationRoot(identityVerificationHub, scopeSeed) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n\n        // -----------------------------------------\n        // 1. Build minimal verification config\n        // -----------------------------------------\n        SelfUtils.UnformattedVerificationConfigV2 memory rawCfg = SelfUtils\n            .UnformattedVerificationConfigV2({\n                olderThan: 0, // No age restriction\n                forbiddenCountries: new string[](0), // Allow all countries\n                ofacEnabled: false // No sanctions screening\n            });\n\n        // -----------------------------------------\n        // 2. Format config for the Hub\n        // -----------------------------------------\n        SelfStructs.VerificationConfigV2 memory formatted = SelfUtils\n            .formatVerificationConfigV2(rawCfg);\n\n        // -----------------------------------------\n        // 3. Register with the Identity Hub (Self)\n        // -----------------------------------------\n        verificationConfigId = IIdentityVerificationHubV2(\n            identityVerificationHub\n        ).setVerificationConfigV2(formatted);\n    }\n\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory\n    ) internal override {\n        address subject = address(uint160(output.userIdentifier));\n        if (verifiedAt[subject] != 0) revert AlreadyVerified(subject);\n\n        // domain separated human fingerprint v1\n        bytes32 dochash = keccak256(\n            abi.encode(\n                keccak256(\"alpha:human:v1\"),\n                output.name,\n                output.nationality,\n                output.dateOfBirth,\n                output.gender,\n                output.issuingState\n            )\n        );\n\n        // mark verified in this module (state before external call)\n        verifiedAt[subject] = block.timestamp;\n\n        // write-back to VerseProfile (ensure vp authorizes this module)\n        if (verseProfile == address(0)) revert ZeroAddress();\n        IVerseProfile vp = IVerseProfile(verseProfile);\n        vp.setHumanVerified(subject, dochash);\n\n        emit HumanVerified(subject, dochash, block.timestamp);\n    }\n\n    // -------------------------\n    // Admin utilities\n    // -------------------------\n    function setVerseProfile(\n        address _verseProfile\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_verseProfile == address(0)) revert ZeroAddress();\n        verseProfile = _verseProfile;\n        emit VerseProfileUpdated(_verseProfile);\n    }\n\n    function setConfigId(bytes32 configId_) external onlyRole(ADMIN_ROLE) {\n        verificationConfigId = configId_;\n        emit VerificationConfigIdUpdated(configId_);\n    }\n\n    /// Admin-revoke verification and sync back to VerseProfile\n    function revokeVerification(address subject) external onlyRole(ADMIN_ROLE) {\n        if (verifiedAt[subject] == 0) revert NotVerified(subject);\n        verifiedAt[subject] = 0;\n        if (verseProfile == address(0)) revert ZeroAddress();\n        IVerseProfile(verseProfile).setHumanVerified(subject, bytes32(\"\"));\n        emit HumanRevoked(subject, msg.sender, block.timestamp);\n    }\n\n    // -------------------------\n    // Self override to provide config id for verification\n    // -------------------------\n    // This returns the config id to the hub when requested. Frontend and contract config must match.\n    function getConfigId(\n        bytes32,\n        bytes32,\n        bytes memory\n    ) public view override returns (bytes32) {\n        return verificationConfigId;\n    }\n\n    // -------------------------\n    // View helpers\n    // -------------------------\n    function isHuman(address who) external view returns (bool) {\n        return verifiedAt[who] != 0;\n    }\n}\n"
      },
      "project/contracts/core/ReputationHub.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * VerseReputationHub (UUPS Upgradeable)\n *\n * - Central hub for reputation across all 4lph4Verse apps.\n * - Apps dont need to pass their appId; hub auto-detects via VerseAppRegistry.\n * - Only registered app.writer contracts can write.\n * - Tracks per-app and per-token activity for each Verse profile.\n * - Delegates scoring logic to pluggable score models per app.\n */\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@verse/contracts/interfaces/IVerseAppRegistry.sol\";\n\ncontract VerseReputationHub is Initializable, UUPSUpgradeable, AccessControlUpgradeable {\n    // ---------- Roles ----------\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // ---------- Types ----------\n    struct Activity {\n        uint64 completedCount;\n        uint64 cancelledCount;\n        mapping(address => uint256) tokenEarned; // token => amount earned\n    }\n\n    // ---------- Storage ----------\n    IVerseAppRegistry public appRegistry;\n\n    // verseId => appId => Activity\n    mapping(uint256 => mapping(bytes32 => Activity)) private activities;\n\n    // ---------- Events ----------\n    event ActivityLogged(\n        uint256 indexed verseId,\n        bytes32 indexed appId,\n        string action,          // \"completed\", \"cancelled\", \"earned\"\n        uint256 amount,\n        address token\n    );\n\n    event RegistrySet(address registry);\n\n    // ---------- Init ----------\n    function initialize(address admin, address appRegistry_) external initializer {\n        require(admin != address(0), \"bad admin\");\n        require(appRegistry_ != address(0), \"bad registry\");\n\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n\n        appRegistry = IVerseAppRegistry(appRegistry_);\n        emit RegistrySet(appRegistry_);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(ADMIN_ROLE) {}\n\n    // ---------- Internals ----------\n    /// @notice Find the appId that matches msg.sender as writer\n    function _resolveAppId() internal view returns (bytes32 appId) {\n        bytes32[] memory ids = appRegistry.allAppIds();\n        for (uint256 i = 0; i < ids.length; i++) {\n            IVerseAppRegistry.App memory app = appRegistry.getApp(ids[i]);\n            if (app.active && app.writer == msg.sender) {\n                return ids[i];\n            }\n        }\n        revert(\"caller not registered writer\");\n    }\n\n    // ---------- Core: Write ----------\n    function logCompleted(uint256 verseId, address token, uint256 amount) external {\n        bytes32 appId = _resolveAppId();\n        Activity storage a = activities[verseId][appId];\n        a.completedCount += 1;\n        if (token != address(0) && amount > 0) {\n            a.tokenEarned[token] += amount;\n        }\n        emit ActivityLogged(verseId, appId, \"completed\", amount, token);\n    }\n\n    function logCancelled(uint256 verseId) external {\n        bytes32 appId = _resolveAppId();\n        Activity storage a = activities[verseId][appId];\n        a.cancelledCount += 1;\n        emit ActivityLogged(verseId, appId, \"cancelled\", 0, address(0));\n    }\n\n    // ---------- Views ----------\n    function getActivity(uint256 verseId, bytes32 appId, address token)\n        external view\n        returns (uint64 completed, uint64 cancelled, uint256 earned)\n    {\n        Activity storage a = activities[verseId][appId];\n        return (a.completedCount, a.cancelledCount, a.tokenEarned[token]);\n    }\n\n    function getRawCounts(uint256 verseId, bytes32 appId)\n        external view\n        returns (uint64 completed, uint64 cancelled)\n    {\n        Activity storage a = activities[verseId][appId];\n        return (a.completedCount, a.cancelledCount);\n    }\n\n    // ---------- Admin ----------\n    function setAppRegistry(address newRegistry) external onlyRole(ADMIN_ROLE) {\n        require(newRegistry != address(0), \"zero\");\n        appRegistry = IVerseAppRegistry(newRegistry);\n        emit RegistrySet(newRegistry);\n    }\n\n    // ---------- Storage gap ----------\n    uint256[45] private __gap;\n}\n"
      },
      "project/contracts/core/ScoreAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * VerseScoreAggregator (UUPS Upgradeable)\n *\n * - Read-only aggregator that computes a user's global Verse score.\n * - Pulls app list + weights + scoreModel from VerseAppRegistry.\n * - Calls each app's IScoreModel to get raw score; applies weightBps; sums.\n * - Returns both total score and a per-app breakdown for UIs/analytics.\n *\n * Notes:\n * - If an app is inactive, has zero weight, or no scoreModel, it contributes 0.\n * - This contract holds no mutable scoring state; only the registry address is configurable.\n */\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@verse/contracts/interfaces/IVerseAppRegistry.sol\";\nimport \"@verse/contracts/interfaces/IScoreModel.sol\";\n\ncontract VerseScoreAggregator is Initializable, UUPSUpgradeable, AccessControlUpgradeable {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    IVerseAppRegistry public registry;\n\n    event RegistrySet(address registry);\n\n    struct AppPart {\n        bytes32 appId;\n        uint256 rawScore;      // score from the app's model\n        uint16  weightBps;     // weighting from registry\n        uint256 weightedScore; // rawScore * weightBps / 10000\n        bool    active;        // registry flag\n        address scoreModel;    // model used (0 if none)\n    }\n\n    function initialize(address admin, address registry_) external initializer {\n        require(admin != address(0) && registry_ != address(0), \"bad init\");\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n        registry = IVerseAppRegistry(registry_);\n        emit RegistrySet(registry_);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(ADMIN_ROLE) {}\n\n    // Admin: swap to a new registry if governance updates it\n    function setRegistry(address newRegistry) external onlyRole(ADMIN_ROLE) {\n        require(newRegistry != address(0), \"zero\");\n        registry = IVerseAppRegistry(newRegistry);\n        emit RegistrySet(newRegistry);\n    }\n\n    // -------- Views --------\n\n    /// @notice Returns total weighted score + per-app breakdown for a verseId\n    function fullScore(uint256 verseId) external view returns (uint256 total, AppPart[] memory parts) {\n        bytes32[] memory ids = registry.allAppIds();\n        parts = new AppPart[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            IVerseAppRegistry.App memory app = registry.getApp(ids[i]);\n\n            uint256 raw = 0;\n            if (app.active && app.scoreModel != address(0) && app.weightBps > 0) {\n                raw = IScoreModel(app.scoreModel).scoreOf(verseId);\n            }\n            uint256 weighted = (raw * app.weightBps) / 10_000;\n\n            parts[i] = AppPart({\n                appId: ids[i],\n                rawScore: raw,\n                weightBps: app.weightBps,\n                weightedScore: weighted,\n                active: app.active,\n                scoreModel: app.scoreModel\n            });\n\n            total += weighted;\n        }\n    }\n\n    /// @notice Convenience: just the summed global score\n    function globalScore(uint256 verseId) external view returns (uint256 total) {\n        bytes32[] memory ids = registry.allAppIds();\n        for (uint256 i = 0; i < ids.length; i++) {\n            IVerseAppRegistry.App memory app = registry.getApp(ids[i]);\n            if (!(app.active && app.scoreModel != address(0) && app.weightBps > 0)) continue;\n            uint256 raw = IScoreModel(app.scoreModel).scoreOf(verseId);\n            total += (raw * app.weightBps) / 10_000;\n        }\n    }\n\n    /// @notice Per-app score preview (raw + weighted) for one appId\n    function appScore(bytes32 appId, uint256 verseId) external view returns (uint256 raw, uint256 weighted, uint16 weightBps, bool active, address scoreModel) {\n        IVerseAppRegistry.App memory app = registry.getApp(appId);\n        active = app.active;\n        scoreModel = app.scoreModel;\n        weightBps = app.weightBps;\n\n        if (active && scoreModel != address(0) && weightBps > 0) {\n            raw = IScoreModel(scoreModel).scoreOf(verseId);\n            weighted = (raw * weightBps) / 10_000;\n        } else {\n            raw = 0;\n            weighted = 0;\n        }\n    }\n\n    // storage gap\n    uint256[45] private __gap;\n}\n"
      },
      "project/contracts/core/ScoreModelBase.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@verse/contracts/interfaces/IScoreModel.sol\";\nimport \"@verse/contracts/interfaces/IVerseReputationHub.sol\";\n\n// ---------- External Interfaces ----------\n\n/// @title ScoreModelBase\n/// @notice Abstract base for app-specific scoring models in the 4lph4Verse.\n/// @dev Each app should deploy its own score model extending this base and override `_computeScore`.\nabstract contract ScoreModelBase is IScoreModel {\n    /// @notice The fixed appId this model scores (e.g., keccak256(\"HireCore\")).\n    bytes32 public immutable appId;\n\n    /// @notice Reputation hub address (read-only).\n    IVerseReputationHub public immutable reputationHub;\n\n    constructor(bytes32 _appId, address _hub) {\n        require(_appId != 0, \"bad appId\");\n        require(_hub != address(0), \"bad hub\");\n        appId = _appId;\n        reputationHub = IVerseReputationHub(_hub);\n    }\n\n    /// @inheritdoc IScoreModel\n    function scoreOf(uint256 verseId) external view override returns (uint256) {\n        return _computeScore(verseId);\n    }\n\n    /// @notice Hook for child contracts: implement app-specific scoring logic.\n    /// @param verseId The Verse profile ID to score.\n    /// @return score Computed score.\n    function _computeScore(\n        uint256 verseId\n    ) internal view virtual returns (uint256 score);\n}\n"
      },
      "project/contracts/core/selfRecoveryModule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/*\n ProofOfOwner.sol\n\n - Inherits SelfVerificationRoot from @selfxyz/contracts (your installed package)\n - On successful Self verification, recovers the profile of a user\n   writes result back to a VerseProfile contract via a minimal interface.\n\n*/\n\nimport \"@selfxyz/contracts/contracts/abstract/SelfVerificationRoot.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SelfUtils} from \"@selfxyz/contracts/contracts/libraries/SelfUtils.sol\";\nimport {SelfStructs} from \"@selfxyz/contracts/contracts/libraries/SelfStructs.sol\";\nimport {IIdentityVerificationHubV2} from \"@selfxyz/contracts/contracts/interfaces/IIdentityVerificationHubV2.sol\";\nimport {IVerseProfile} from \"../interfaces/IVerseProfile.sol\";\n\ncontract selfRecoveryModule is AccessControl, SelfVerificationRoot {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    /// @notice reference to VerseProfile contract (single source of truth)\n    address public verseProfile;\n\n    /// @notice config id returned by getConfigId (optional)\n    bytes32 public verificationConfigId;\n\n    /// @notice  scope seed recorded locally (for SDK/frontend)\n    string public scopeSeed = \"proof-of-owner\";\n\n    /// @notice events\n    event HumanVerified(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 output,\n        uint256 timestamp,\n        bytes userData\n    );\n\n    event VerificationConfigIdUpdated(bytes32 configId);\n    event VerseProfileUpdated(address indexed verseProfile);\n\n    error ZeroAddress();\n    error NotVerified(address who);\n\n    constructor(\n        address identityVerificationHub\n    ) SelfVerificationRoot(identityVerificationHub, scopeSeed) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n\n        // -----------------------------------------\n        // Build  verification config\n        // -----------------------------------------\n        SelfUtils.UnformattedVerificationConfigV2 memory rawCfg = SelfUtils\n            .UnformattedVerificationConfigV2({\n                olderThan: 0, // No age restriction\n                forbiddenCountries: new string[](0), // Allow all countries\n                ofacEnabled: false // No sanctions screening\n            });\n\n        // -----------------------------------------\n        // Format config for the Hub\n        // -----------------------------------------\n        SelfStructs.VerificationConfigV2 memory formatted = SelfUtils\n            .formatVerificationConfigV2(rawCfg);\n\n        // -----------------------------------------\n        // Register with the Identity Hub (Self)\n        // -----------------------------------------\n        verificationConfigId = IIdentityVerificationHubV2(\n            identityVerificationHub\n        ).setVerificationConfigV2(formatted);\n    }\n\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal override {\n        address subject;\n        bytes32 dochash;\n        address verifier = address(uint160(output.userIdentifier));\n        if (userData.length == 20) {\n            // packed 20-byte address from abi.encodePacked(address)\n            subject = address(uint160(bytes20(userData)));\n        } else {\n            // standard abi.encode(address)\n            subject = abi.decode(userData, (address));\n        }\n\n        dochash = keccak256(\n            abi.encode(\n                output.name,\n                output.idNumber,\n                output.nationality,\n                output.dateOfBirth,\n                output.gender\n            )\n        );\n\n        if (verseProfile == address(0)) revert ZeroAddress();\n        IVerseProfile vp = IVerseProfile(verseProfile);\n        uint256 verseId = vp.verseIdOfOwner(subject);\n        bytes32 verifiedHash = vp.getDochash(verseId);\n        if (verifiedHash != bytes32(\"\") && verifiedHash == dochash) {\n            vp.recoverySetOwner(verseId, verifier);\n        }\n\n    }\n\n    // -------------------------\n    // Admin utilities\n    // -------------------------\n    function setVerseProfile(\n        address _verseProfile\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_verseProfile == address(0)) revert ZeroAddress();\n        verseProfile = _verseProfile;\n        emit VerseProfileUpdated(_verseProfile);\n    }\n\n    function setConfigId(bytes32 configId_) external onlyRole(ADMIN_ROLE) {\n        verificationConfigId = configId_;\n        emit VerificationConfigIdUpdated(configId_);\n    }\n\n    // -------------------------\n    // Self override to provide config id for verification\n    // -------------------------\n    // This returns the config id to the hub when requested. Frontend and contract config must match.\n    function getConfigId(\n        bytes32,\n        bytes32,\n        bytes memory\n    ) public view override returns (bytes32) {\n        return verificationConfigId;\n    }\n}\n"
      },
      "project/contracts/core/VerseProfile.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title VerseProfile v2 (Core)\n * @notice Root identity for the 4lph4Verse. Soulbound VerseID per wallet.\n *         Minimal on-chain state; rich off-chain metadata. Modules extend behavior.\n *\n * Key features:\n *  - One profile per wallet (soulbound; no transfers)\n *  - Global unique handle (case-insensitive via normalization)\n *  - Purpose tag (why this profile exists in the Verse)\n *  - Metadata URI (ipfs:// or https://)\n *  - Delegate/guardian for management\n *  - UUPS upgradeability + roles + pausable\n *  - EIP-712 meta-transactions for gasless updates\n *  - Module system with per-hook subscriptions and cheap dispatch\n *\n * Notes:\n *  - ENS linkage intentionally removed (can live in metadata or a module)\n *  - App-specific nicknames moved to a module to keep core slim\n */\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\ninterface IVerseModule {\n    /**\n     * @dev Generic hook for Verse lifecycle events.\n     * @param hook   keccak256(\"onProfileCreated\"), keccak256(\"onHandleChanged\"), etc.\n     * @param verseId The VerseID the event pertains to\n     * @param data   ABI-encoded aux data, schema per hook\n     *\n     * Expected signatures (examples):\n     *   - onProfileCreated: abi.encode(address owner, string handle, string purpose)\n     *   - onHandleChanged:  abi.encode(string oldHandle, string newHandle)\n     *   - onPurposeUpdated: abi.encode(string newPurpose)\n     *   - onMetadataSet:    abi.encode(string newURI)\n     *   - onDelegateSet:    abi.encode(address newDelegate)\n     */\n    function onVerseEvent(\n        bytes32 hook,\n        uint256 verseId,\n        bytes calldata data\n    ) external;\n}\n\ncontract VerseProfile is\n    Initializable,\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    EIP712Upgradeable\n{\n    using ECDSA for bytes32;\n\n    // -------------------- Roles --------------------\n    bytes32 public constant PROFILE_ADMIN_ROLE =\n        keccak256(\"PROFILE_ADMIN_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n\n    // -------------------- Hook IDs --------------------\n    // (pre-computed constants to save a tiny bit of gas vs keccak at runtime)\n    bytes32 public constant HOOK_ON_PROFILE_CREATED =\n        keccak256(\"onProfileCreated\");\n    bytes32 public constant HOOK_ON_HANDLE_CHANGED =\n        keccak256(\"onHandleChanged\");\n    bytes32 public constant HOOK_ON_PURPOSE_UPDATED =\n        keccak256(\"onPurposeUpdated\");\n    bytes32 public constant HOOK_ON_METADATA_SET = keccak256(\"onMetadataSet\");\n    bytes32 public constant HOOK_ON_DELEGATE_SET = keccak256(\"onDelegateSet\");\n\n    // -------------------- Types & Storage --------------------\n    struct Profile {\n        address owner; // wallet or smart account\n        string handle; // globally unique, normalized lowercase\n        string metadataURI; // ipfs://... or https://...\n        string purpose; // human-readable purpose\n        address delegate; // optional manager/guardian\n        uint64 createdAt; // block.timestamp\n        uint8 version; // schema version\n        bytes32 dochash; // proof of verification\n    }\n    struct ProfileSum {\n        address owner;\n        string handle;\n        string metadataURI;\n        string purpose;\n        address delegate;\n        uint64 createdAt;\n        uint8 version;\n        bool verified;\n    }\n\n    uint256 public nextVerseId; // starts at 1\n\n    mapping(uint256 => Profile) private _profiles; // verseId => Profile\n    mapping(address => uint256) public profileOf; // wallet  => verseId\n    mapping(bytes32 => uint256) private _handleToId; // keccak256(handleLower) => verseId\n\n    // EIP-712 nonces (per verseId)\n    mapping(uint256 => uint256) public nonces;\n    mapping(address => uint256) public createNonces;\n\n    // Module registry\n    mapping(bytes32 => address) public modules; // key => module address\n\n    // Per-hook subscriptions (cheap dispatch)\n    mapping(bytes32 => address[]) private _hookSubs; // hook => subscribers\n\n    // -------------------- Constants --------------------\n\n    bytes4 constant _ERC1271_MAGIC = 0x1626ba7e;\n\n    // -------------------- Events --------------------\n    event ProfileCreated(\n        uint256 indexed verseId,\n        address indexed owner,\n        string handle,\n        string purpose,\n        string metadataURI\n    );\n    event HandleChanged(\n        uint256 indexed verseId,\n        string oldHandle,\n        string newHandle\n    );\n    event MetadataURISet(uint256 indexed verseId, string newURI);\n    event PurposeUpdated(uint256 indexed verseId, string newPurpose);\n    event DelegateSet(uint256 indexed verseId, address indexed delegate);\n    event ModuleRegistered(bytes32 indexed key, address indexed module);\n    event ModuleRemoved(bytes32 indexed key, address indexed module);\n    event HookSubscribed(bytes32 indexed hook, address indexed module);\n    event HookUnsubscribed(bytes32 indexed hook, address indexed module);\n    event ModuleCallFailed(\n        bytes32 indexed hook,\n        uint256 indexed verseId,\n        address indexed module\n    );\n    event OwnerRecovered(\n        uint256 indexed verseId,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n    event DelegateResetByRecovery(\n        uint256 indexed verseId,\n        address indexed oldDelegate\n    );\n    event HumanVerified(uint256 indexed verseId);\n\n    // -------------------- UUPS: disable impl init --------------------\n    constructor() {\n        _disableInitializers();\n    }\n\n    // -------------------- Initialize --------------------\n    function initialize(address admin) external initializer {\n        require(admin != address(0), \"bad admin\");\n\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        __AccessControl_init();\n        __EIP712_init(\"VerseProfile\", \"0.1\"); // bump if EIP-712 structs change\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(PROFILE_ADMIN_ROLE, admin);\n        _grantRole(UPGRADER_ROLE, admin);\n\n        nextVerseId = 1;\n    }\n\n    // -------------------- Access / Upgrade --------------------\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(UPGRADER_ROLE) {}\n\n    // -------------------- Views --------------------\n    function getProfile(\n        uint256 verseId\n    ) external view returns (Profile memory) {\n        require(_profiles[verseId].owner != address(0), \"Invalid profile\");\n\n        return _profiles[verseId];\n    }\n\n    function getProfileByHandle(\n        string calldata handle\n    ) external view returns (Profile memory) {\n        uint256 verseId = _handleToId[_handleKey(_normalize(handle))];\n        require(verseId != 0, \"Handle not found\");\n        return _profiles[verseId];\n    }\n\n    function getDochash(uint256 verseId) external view returns (bytes32) {\n        return _profiles[verseId].dochash;\n    }\n\n    function verseIdByHandle(\n        string calldata handle\n    ) external view returns (uint256) {\n        return _handleToId[_handleKey(_normalize(handle))];\n    }\n\n    function verseIdOfOwner(address owner) external view returns (uint256) {\n        return profileOf[owner];\n    }\n\n    function ownerOf(uint256 verseId) external view returns (address) {\n        require(_profiles[verseId].owner != address(0), \"Invalid profile\");\n\n        return _profiles[verseId].owner;\n    }\n\n    function hasProfile(address user) external view returns (bool) {\n        return profileOf[user] != 0;\n    }\n\n    function getProfileSummary(\n        uint256 verseId\n    ) external view returns (ProfileSum memory) {\n        require(_profiles[verseId].owner != address(0), \"Invalid profile\");\n\n        Profile memory p = _profiles[verseId];\n        require(p.owner != address(0), \"Invalid profile\");\n\n        return\n            ProfileSum({\n                owner: p.owner,\n                handle: p.handle,\n                metadataURI: p.metadataURI,\n                purpose: p.purpose,\n                delegate: p.delegate,\n                createdAt: p.createdAt,\n                version: p.version,\n                verified: p.dochash != bytes32(0)\n            });\n    }\n\n    function profileExists(uint256 verseId) external view returns (bool) {\n        return _profiles[verseId].owner != address(0);\n    }\n\n    function getProfileByOwner(\n        address owner\n    ) external view returns (Profile memory p, uint256 verseId) {\n        verseId = profileOf[owner];\n        require(verseId != 0, \"VerseProfile: no profile\");\n        p = _profiles[verseId];\n    }\n\n    function isHandleAvailable(\n        string calldata handle\n    ) external view returns (bool) {\n        string memory norm = _normalize(handle);\n        if (bytes(norm).length == 0) return false;\n        return _handleToId[_handleKey(norm)] == 0;\n    }\n\n    function isOwnerOrDelegate(\n        uint256 verseId,\n        address account\n    ) external view returns (bool) {\n        Profile storage p = _profiles[verseId];\n        if (p.owner == address(0)) return false;\n        return account == p.owner || account == p.delegate;\n    }\n\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    // -------------------- Core: Create --------------------\n    function createProfile(\n        string calldata handle,\n        string calldata metadataURI,\n        string calldata purpose\n    ) external whenNotPaused returns (uint256 verseId) {\n        address sender = _msgSender();\n        require(profileOf[sender] == 0, \"already have profile\");\n\n        // Normalize & claim handle\n        string memory norm = _normalize(handle);\n        require(bytes(norm).length != 0, \"empty handle\");\n\n        bytes32 key = _handleKey(norm);\n        uint256 existing = _handleToId[key];\n        require(existing == 0, \"handle taken\");\n\n        verseId = nextVerseId++;\n        _profiles[verseId] = Profile({\n            owner: sender,\n            handle: norm,\n            metadataURI: metadataURI,\n            purpose: purpose,\n            delegate: address(0),\n            createdAt: uint64(block.timestamp),\n            version: 2,\n            dochash: bytes32(0)\n        });\n        profileOf[sender] = verseId;\n\n        _handleToId[key] = verseId;\n\n        emit ProfileCreated(verseId, sender, norm, purpose, metadataURI);\n\n        // Minimal synchronous hooks (keep subscriber list short)\n        _trigger(\n            HOOK_ON_PROFILE_CREATED,\n            verseId,\n            abi.encode(sender, norm, purpose)\n        );\n    }\n\n    // -------------------- Owner/Delegate actions --------------------\n    function setHandle(\n        uint256 verseId,\n        string calldata newHandle\n    ) external whenNotPaused {\n        _requireOwnerOrDelegate(verseId);\n\n        string memory norm = _normalize(newHandle);\n        require(bytes(norm).length != 0, \"empty handle\");\n        bytes32 key = _handleKey(norm);\n\n        uint256 existing = _handleToId[key];\n        require(existing == 0 || existing == verseId, \"handle taken\");\n\n        // free old\n        string memory old = _profiles[verseId].handle;\n        if (bytes(old).length != 0) {\n            _handleToId[_handleKey(old)] = 0;\n        }\n\n        _profiles[verseId].handle = norm;\n        _handleToId[key] = verseId;\n        emit HandleChanged(verseId, old, norm);\n\n        _trigger(HOOK_ON_HANDLE_CHANGED, verseId, abi.encode(old, norm));\n    }\n\n    function setMetadataURI(\n        uint256 verseId,\n        string calldata newURI\n    ) external whenNotPaused {\n        _requireOwnerOrDelegate(verseId);\n        _profiles[verseId].metadataURI = newURI;\n        emit MetadataURISet(verseId, newURI);\n\n        // Prefer event-only for most modules; still provide hook for those that opt-in.\n        _trigger(HOOK_ON_METADATA_SET, verseId, abi.encode(newURI));\n    }\n\n    function setPurpose(\n        uint256 verseId,\n        string calldata newPurpose\n    ) external whenNotPaused {\n        _requireOwnerOrDelegate(verseId);\n        _profiles[verseId].purpose = newPurpose;\n        emit PurposeUpdated(verseId, newPurpose);\n\n        _trigger(HOOK_ON_PURPOSE_UPDATED, verseId, abi.encode(newPurpose));\n    }\n\n    function setDelegate(\n        uint256 verseId,\n        address newDelegate\n    ) external whenNotPaused {\n        _requireOwnerOrDelegate(verseId);\n        _profiles[verseId].delegate = newDelegate;\n        emit DelegateSet(verseId, newDelegate);\n\n        _trigger(HOOK_ON_DELEGATE_SET, verseId, abi.encode(newDelegate));\n    }\n\n    // -------------------- Gasless: EIP-712 meta-ops --------------------\n    struct CreateProfileWithSig {\n        address owner;\n        string handle;\n        string metadataURI;\n        string purpose;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    bytes32 private constant _CREATE_PROFILE_TYPEHASH =\n        keccak256(\n            \"CreateProfileWithSig(address owner,string handle,string metadataURI,string purpose,uint256 nonce,uint256 deadline)\"\n        );\n\n    function createProfileWithSig(\n        CreateProfileWithSig calldata op,\n        bytes calldata sig\n    ) external whenNotPaused returns (uint256 verseId) {\n        require(block.timestamp <= op.deadline, \"expired\");\n        require(op.nonce == createNonces[op.owner], \"bad nonce\");\n        createNonces[op.owner]++;\n        require(profileOf[op.owner] == 0, \"already have profile\");\n\n        string memory norm = _normalize(op.handle);\n        require(bytes(norm).length != 0, \"empty handle\");\n\n        bytes32 key = _handleKey(norm);\n        uint256 existing = _handleToId[key];\n        require(existing == 0, \"handle taken\");\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _CREATE_PROFILE_TYPEHASH,\n                    op.owner,\n                    keccak256(bytes(norm)),\n                    keccak256(bytes(op.metadataURI)),\n                    keccak256(bytes(op.purpose)),\n                    op.nonce,\n                    op.deadline\n                )\n            )\n        );\n\n        address signer = _resolveSigner(op.owner, digest, sig);\n        require(signer == op.owner, \"not owner\");\n\n        verseId = nextVerseId++;\n        _profiles[verseId] = Profile({\n            owner: op.owner,\n            handle: norm,\n            metadataURI: op.metadataURI,\n            purpose: op.purpose,\n            delegate: address(0),\n            createdAt: uint64(block.timestamp),\n            version: 2,\n            dochash: bytes32(0)\n        });\n\n        profileOf[op.owner] = verseId;\n        if (bytes(norm).length != 0) {\n            _handleToId[_handleKey(norm)] = verseId;\n        }\n\n        emit ProfileCreated(\n            verseId,\n            op.owner,\n            norm,\n            op.purpose,\n            op.metadataURI\n        );\n        _trigger(\n            HOOK_ON_PROFILE_CREATED,\n            verseId,\n            abi.encode(op.owner, norm, op.purpose)\n        );\n    }\n\n    function setHumanVerified(\n        address subject,\n        bytes32 dochash\n    ) external onlyRole(VERIFIER_ROLE) {\n        uint256 verseId = profileOf[subject];\n        require(verseId != 0, \"VerseProfile: no profile\");\n        Profile storage p = _profiles[verseId];\n        p.dochash = dochash;\n        emit HumanVerified(verseId);\n    }\n\n    struct SetURIWithSig {\n        uint256 verseId;\n        string newURI;\n        uint256 nonce;\n        uint256 deadline;\n    }\n    bytes32 private constant _SET_URI_TYPEHASH =\n        keccak256(\n            \"SetURIWithSig(uint256 verseId,string newURI,uint256 nonce,uint256 deadline)\"\n        );\n\n    function setMetadataWithSig(\n        SetURIWithSig calldata op,\n        bytes calldata sig\n    ) external whenNotPaused {\n        require(block.timestamp <= op.deadline, \"expired\");\n        require(op.nonce == nonces[op.verseId]++, \"bad nonce\");\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _SET_URI_TYPEHASH,\n                    op.verseId,\n                    keccak256(bytes(op.newURI)),\n                    op.nonce,\n                    op.deadline\n                )\n            )\n        );\n        Profile storage p = _profiles[op.verseId];\n        require(p.owner != address(0), \"VerseProfile: no profile\");\n\n        address signer = _resolveSigner(p.owner, digest, sig);\n        require(signer == p.owner, \"not owner\");\n\n        p.metadataURI = op.newURI;\n        emit MetadataURISet(op.verseId, op.newURI);\n        _trigger(HOOK_ON_METADATA_SET, op.verseId, abi.encode(op.newURI));\n    }\n\n    struct SetDelegateWithSig {\n        uint256 verseId;\n        address newDelegate;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    bytes32 private constant _SET_DELEGATE_TYPEHASH =\n        keccak256(\n            \"SetDelegateWithSig(uint256 verseId,address newDelegate,uint256 nonce,uint256 deadline)\"\n        );\n\n    function setDelegateWithSig(\n        SetDelegateWithSig calldata op,\n        bytes calldata sig\n    ) external whenNotPaused {\n        require(block.timestamp <= op.deadline, \"expired\");\n        require(op.nonce == nonces[op.verseId]++, \"bad nonce\");\n\n        Profile storage p = _profiles[op.verseId];\n        require(p.owner != address(0), \"VerseProfile: no profile\");\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _SET_DELEGATE_TYPEHASH,\n                    op.verseId,\n                    op.newDelegate,\n                    op.nonce,\n                    op.deadline\n                )\n            )\n        );\n\n        address signer = _resolveSigner(p.owner, digest, sig);\n        require(signer == p.owner, \"not owner\");\n\n        p.delegate = op.newDelegate;\n        emit DelegateSet(op.verseId, op.newDelegate);\n        _trigger(HOOK_ON_DELEGATE_SET, op.verseId, abi.encode(op.newDelegate));\n    }\n\n    struct SetPurposeWithSig {\n        uint256 verseId;\n        string newPurpose;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    bytes32 private constant _SET_PURPOSE_TYPEHASH =\n        keccak256(\n            \"SetPurposeWithSig(uint256 verseId,string newPurpose,uint256 nonce,uint256 deadline)\"\n        );\n\n    function setPurposeWithSig(\n        SetPurposeWithSig calldata op,\n        bytes calldata sig\n    ) external whenNotPaused {\n        require(block.timestamp <= op.deadline, \"expired\");\n        require(op.nonce == nonces[op.verseId]++, \"bad nonce\");\n\n        Profile storage p = _profiles[op.verseId];\n        require(p.owner != address(0), \"VerseProfile: no profile\");\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _SET_PURPOSE_TYPEHASH,\n                    op.verseId,\n                    keccak256(bytes(op.newPurpose)),\n                    op.nonce,\n                    op.deadline\n                )\n            )\n        );\n\n        address signer = _resolveSigner(p.owner, digest, sig);\n        require(signer == p.owner, \"not owner\");\n\n        p.purpose = op.newPurpose;\n        emit PurposeUpdated(op.verseId, op.newPurpose);\n        _trigger(\n            HOOK_ON_PURPOSE_UPDATED,\n            op.verseId,\n            abi.encode(op.newPurpose)\n        );\n    }\n\n    struct SetHandleWithSig {\n        uint256 verseId;\n        string newHandle;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    bytes32 private constant _SET_HANDLE_TYPEHASH =\n        keccak256(\n            \"SetHandleWithSig(uint256 verseId,string newHandle,uint256 nonce,uint256 deadline)\"\n        );\n\n    function setHandleWithSig(\n        SetHandleWithSig calldata op,\n        bytes calldata sig\n    ) external whenNotPaused {\n        require(block.timestamp <= op.deadline, \"expired\");\n        require(op.nonce == nonces[op.verseId]++, \"bad nonce\");\n\n        Profile storage p = _profiles[op.verseId];\n        require(p.owner != address(0), \"VerseProfile: no profile\");\n\n        string memory norm = _normalize(op.newHandle);\n        require(bytes(norm).length != 0, \"empty handle\");\n        bytes32 key = _handleKey(norm);\n\n        uint256 existing = _handleToId[key];\n        require(existing == 0 || existing == op.verseId, \"handle taken\");\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _SET_HANDLE_TYPEHASH,\n                    op.verseId,\n                    keccak256(bytes(norm)),\n                    op.nonce,\n                    op.deadline\n                )\n            )\n        );\n\n        address signer = _resolveSigner(p.owner, digest, sig);\n        require(signer == p.owner, \"not owner\");\n\n        string memory old = p.handle;\n        if (bytes(old).length != 0) {\n            _handleToId[_handleKey(old)] = 0;\n        }\n\n        p.handle = norm;\n        _handleToId[key] = op.verseId;\n\n        emit HandleChanged(op.verseId, old, norm);\n        _trigger(HOOK_ON_HANDLE_CHANGED, op.verseId, abi.encode(old, norm));\n    }\n\n    // -------------------- Module Registry --------------------\n    function registerModule(\n        bytes32 key,\n        address module\n    ) external onlyRole(PROFILE_ADMIN_ROLE) {\n        require(module != address(0), \"zero module\");\n        modules[key] = module;\n        emit ModuleRegistered(key, module);\n    }\n\n    function removeModule(bytes32 key) external onlyRole(PROFILE_ADMIN_ROLE) {\n        address old = modules[key];\n        modules[key] = address(0);\n        emit ModuleRemoved(key, old);\n    }\n\n    /**\n     * @notice Grant recovery permissions to a GuardianRecoveryModule (or similar).\n     * @dev Callable by PROFILE_ADMIN_ROLE. You can call this multiple times for new modules.\n     */\n    function grantRecoveryModule(\n        address module\n    ) external onlyRole(PROFILE_ADMIN_ROLE) {\n        require(module != address(0), \"VerseProfile: zero module\");\n        _grantRole(RECOVERY_ROLE, module);\n    }\n\n    function subscribeHook(\n        bytes32 hook,\n        address module\n    ) external onlyRole(PROFILE_ADMIN_ROLE) {\n        require(module != address(0), \"zero module\");\n        address[] storage arr = _hookSubs[hook];\n        for (uint i = 0; i < arr.length; i++)\n            require(arr[i] != module, \"already subscribed\");\n        arr.push(module);\n        emit HookSubscribed(hook, module);\n    }\n\n    function unsubscribeHook(\n        bytes32 hook,\n        address module\n    ) external onlyRole(PROFILE_ADMIN_ROLE) {\n        address[] storage arr = _hookSubs[hook];\n        uint256 n = arr.length;\n        for (uint256 i; i < n; ++i) {\n            if (arr[i] == module) {\n                arr[i] = arr[n - 1];\n                arr.pop();\n                emit HookUnsubscribed(hook, module);\n                break;\n            }\n        }\n    }\n\n    function getHookSubscribers(\n        bytes32 hook\n    ) external view returns (address[] memory) {\n        return _hookSubs[hook];\n    }\n\n    /**\n     * @notice Set a new owner for a VerseID during recovery.\n     * @dev Only callable by an address with RECOVERY_ROLE (typically GuardianRecoveryModule).\n     *\n     * Requirements:\n     * - verseId must exist\n     * - newOwner must be non-zero\n     * - newOwner must not already have a profile\n     */\n    function recoverySetOwner(\n        uint256 verseId,\n        address newOwner\n    ) external onlyRole(RECOVERY_ROLE) {\n        require(newOwner != address(0), \"VerseProfile: zero new owner\");\n\n        Profile storage p = _profiles[verseId];\n        address oldOwner = p.owner;\n        require(oldOwner != address(0), \"VerseProfile: no profile\");\n        require(\n            profileOf[newOwner] == 0,\n            \"VerseProfile: new owner already has profile\"\n        );\n\n        profileOf[oldOwner] = 0;\n        profileOf[newOwner] = verseId;\n        p.owner = newOwner;\n\n        if (p.delegate != address(0)) {\n            address oldDelegate = p.delegate;\n            p.delegate = address(0);\n            emit DelegateResetByRecovery(verseId, oldDelegate);\n        }\n\n        emit OwnerRecovered(verseId, oldOwner, newOwner);\n    }\n\n    // -------------------- Pause controls --------------------\n    function pause() external onlyRole(PROFILE_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(PROFILE_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // -------------------- Internal: Hook Dispatch (cheap) --------------------\n    /**\n     * @dev Cheap dispatch: only call subscribed modules for this hook.\n     * Uses a small gas stipend to avoid griefing; ignore failures.\n     */\n    function _trigger(\n        bytes32 hook,\n        uint256 verseId,\n        bytes memory data\n    ) internal {\n        address[] memory subs = _hookSubs[hook];\n        uint256 len = subs.length;\n        for (uint256 i; i < len; ++i) {\n            address m = subs[i];\n            if (m == address(0)) continue;\n\n            (bool success, ) = m.call{gas: 50_000}(\n                abi.encodeWithSelector(\n                    IVerseModule.onVerseEvent.selector,\n                    hook,\n                    verseId,\n                    data\n                )\n            );\n\n            if (!success) emit ModuleCallFailed(hook, verseId, m);\n        }\n    }\n\n    // -------------------- Internal: Utils --------------------\n    function _requireOwnerOrDelegate(uint256 verseId) internal view {\n        Profile storage p = _profiles[verseId];\n        address s = _msgSender();\n        require(s == p.owner || s == p.delegate, \"no auth\");\n    }\n\n    function _handleKey(string memory lower) internal pure returns (bytes32) {\n        return keccak256(bytes(lower));\n    }\n\n    function _normalize(string memory s) internal pure returns (string memory) {\n        // ASCII lowercase normalization; extendable to full unicode if needed.\n        bytes memory b = bytes(s);\n        for (uint256 i; i < b.length; ++i) {\n            uint8 c = uint8(b[i]);\n            if (c >= 65 && c <= 90) {\n                // 'A'..'Z'\n                b[i] = bytes1(c + 32);\n            }\n        }\n        return string(b);\n    }\n\n    // Resolve EOA vs Smart Account (EIP-1271)\n    function _resolveSigner(\n        address owner,\n        bytes32 digest,\n        bytes calldata sig\n    ) internal view returns (address) {\n        if (owner.code.length == 0) {\n            return ECDSA.recover(digest, sig);\n        } else {\n            bytes4 ok = IERC1271(owner).isValidSignature(digest, sig);\n            require(ok == _ERC1271_MAGIC, \"bad 1271 sig\");\n            return owner;\n        }\n    }\n\n    // -------------------- ERC165 --------------------\n    function supportsInterface(\n        bytes4 iid\n    ) public view override(AccessControlUpgradeable) returns (bool) {\n        return super.supportsInterface(iid);\n    }\n\n    // -------------------- Storage gap --------------------\n    uint256[44] private __gap;\n}\n"
      },
      "project/contracts/hirecore/HireCoreScoreModel.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * HireCoreScoreModel\n *\n * - Implements IScoreModel for HireCore jobs.\n * - Reads completed/cancelled activity from VerseReputationHub.\n * - Computes a raw score = completed * COMPLETED_WEIGHT - cancelled * CANCELLED_PENALTY\n * - Future-proof: weights are configurable by ADMIN_ROLE.\n *\n * Example scoring:\n * - Each completed job = +100 points\n * - Each cancelled job = -50 points\n * - Earned tokens can also be included later as multipliers.\n */\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IScoreModel.sol\";\nimport \"../interfaces/IVerseReputationHub.sol\";\n\ncontract HireCoreScoreModel is\n    Initializable,\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    IScoreModel\n{\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    IVerseReputationHub public hub;\n    bytes32 public constant APP_ID = keccak256(\"HireCore\");\n\n    // scoring parameters\n    uint256 public completedWeight;\n    uint256 public cancelledPenalty;\n\n    event HubSet(address hub);\n    event WeightsUpdated(uint256 completedWeight, uint256 cancelledPenalty);\n\n    function initialize(address admin, address hub_) external initializer {\n        require(admin != address(0) && hub_ != address(0), \"bad init\");\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n\n        hub = IVerseReputationHub(hub_);\n        completedWeight = 100; // default: +100 points per completed\n        cancelledPenalty = 50; // default: -50 points per cancelled\n\n        emit HubSet(hub_);\n        emit WeightsUpdated(completedWeight, cancelledPenalty);\n    }\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(ADMIN_ROLE) {}\n\n    // --- Admin controls ---\n    function setHub(address hub_) external onlyRole(ADMIN_ROLE) {\n        require(hub_ != address(0), \"zero\");\n        hub = IVerseReputationHub(hub_);\n        emit HubSet(hub_);\n    }\n\n    function setWeights(\n        uint256 completedWeight_,\n        uint256 cancelledPenalty_\n    ) external onlyRole(ADMIN_ROLE) {\n        completedWeight = completedWeight_;\n        cancelledPenalty = cancelledPenalty_;\n        emit WeightsUpdated(completedWeight_, cancelledPenalty_);\n    }\n\n    // --- Score calculation ---\n    function scoreOf(uint256 verseId) external view override returns (uint256) {\n        (uint64 completed, uint64 cancelled) = hub.getRawCounts(\n            verseId,\n            APP_ID\n        );\n\n        // safe math: cancellation penalty cannot underflow\n        uint256 score = (completed * completedWeight);\n        uint256 penalty = (cancelled * cancelledPenalty);\n\n        if (penalty >= score) {\n            return 0; // floor at zero\n        }\n        return score - penalty;\n    }\n\n    // storage gap for upgrades\n    uint256[45] private __gap;\n}\n"
      },
      "project/contracts/hirecore/JobBoard.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title HireCoreJobBoard\n * @notice Decentralized job posting and application board for HireCore.\n *\n * @dev\n * - Built with UUPSUpgradeable for safe upgrades.\n * - Posts require a CORE token deposit to mitigate spam.\n * - Workers can apply with bids + proposals.\n * - Hirers can accept applications  spawns an onchain Job via JobManager.\n * - Deposits are refunded when a post is closed/accepted; slashed to treasury if expired.\n *\n * ### Future-Proof:\n * - All critical params (treasury, jobManager, coreToken, minDeposit) are admin-upgradable.\n * - Storage gap reserved at end for new variables.\n * - Compact and indexer-friendly event design.\n */\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @dev Minimal interface to JobManager (which manages lifecycle & funds).\nimport \"../interfaces/IJobManager.sol\";\n\ncontract HireCoreJobBoard is\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    // ---------- Roles ----------\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // ---------- Config ----------\n    IERC20 public coreToken; // anti-spam deposit token\n    address public treasury; // slashed deposits go here\n    uint256 public minDeposit; // minimum deposit per post\n    IJobManager public jobManager; // JobManager contract (spawn jobs)\n\n    // ---------- Types ----------\n    struct JobPost {\n        address hirer;\n        address paymentToken;\n        uint256 budgetMax;\n        uint64 expiry;\n        uint256 deposit;\n        string metadataURI;\n        bool open;\n    }\n\n    struct AcceptParams {\n        uint256 postId;\n        uint256 appIndex;\n        address worker;\n        address paymentToken;\n        uint64 deadline;\n        string metadataURI;\n        IJobManager.JobType jobType;\n        uint256[] amounts;\n        uint64[] dueDates;\n        bool[] requiresDeliverable;\n    }\n\n    struct Application {\n        address worker;\n        uint256 bidAmount;\n        string proposalURI;\n        bool withdrawn;\n    }\n\n    // ---------- Storage ----------\n    uint256 public nextPostId;\n    mapping(uint256 => JobPost) public posts;\n    mapping(uint256 => Application[]) public applications;\n\n    // ---------- Events ----------\n    event PostCreated(\n        uint256 indexed postId,\n        address indexed hirer,\n        address token,\n        uint256 budgetMax,\n        uint64 expiry,\n        uint256 deposit,\n        string metadataURI\n    );\n    event PostClosed(uint256 indexed postId, address indexed hirer);\n    event PostExpired(uint256 indexed postId, address indexed hirer);\n    event PostDepositSlashed(\n        uint256 indexed postId,\n        address indexed hirer,\n        uint256 amount\n    );\n\n    event Applied(\n        uint256 indexed postId,\n        uint256 indexed appIndex,\n        address indexed worker,\n        uint256 bid,\n        string proposalURI\n    );\n    event ApplicationWithdrawn(\n        uint256 indexed postId,\n        uint256 indexed appIndex,\n        address indexed worker\n    );\n    event ApplicationAccepted(\n        uint256 indexed postId,\n        uint256 indexed appIndex,\n        uint256 jobId\n    );\n\n    // ---------- Constructor ----------\n    constructor() {\n        _disableInitializers();\n    }\n\n    // ---------- Init ----------\n    function initialize(\n        address admin,\n        address jobManager_,\n        address coreToken_,\n        address treasury_,\n        uint256 minDeposit_\n    ) external initializer {\n        require(admin != address(0), \"bad admin\");\n        require(jobManager_ != address(0), \"bad jobManager\");\n        require(coreToken_ != address(0), \"bad coreToken\");\n        require(treasury_ != address(0), \"bad treasury\");\n\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n\n        jobManager = IJobManager(jobManager_);\n        coreToken = IERC20(coreToken_);\n        treasury = treasury_;\n        minDeposit = minDeposit_;\n        nextPostId = 1;\n    }\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(ADMIN_ROLE) {}\n\n    // ---------- Hirer: Create Post ----------\n    /**\n     * @notice Create a new job post.\n     * @param paymentToken ERC20 token for payment.\n     * @param budgetMax Maximum budget for this job.\n     * @param duration Duration (seconds) until expiry (min 1 day, max 30 days).\n     * @param metadataURI IPFS/Arweave JSON with job description.\n     */\n    function createPost(\n        address paymentToken,\n        uint256 budgetMax,\n        uint64 duration,\n        string calldata metadataURI\n    ) external nonReentrant returns (uint256 postId) {\n        require(budgetMax > 0, \"budget required\");\n        require(duration >= 1 days && duration <= 30 days, \"invalid duration\");\n\n        // lock CORE deposit\n        coreToken.safeTransferFrom(msg.sender, address(this), minDeposit);\n\n        postId = nextPostId++;\n        posts[postId] = JobPost({\n            hirer: msg.sender,\n            paymentToken: paymentToken,\n            budgetMax: budgetMax,\n            expiry: uint64(block.timestamp + duration),\n            deposit: minDeposit,\n            metadataURI: metadataURI,\n            open: true\n        });\n\n        emit PostCreated(\n            postId,\n            msg.sender,\n            paymentToken,\n            budgetMax,\n            uint64(block.timestamp + duration),\n            minDeposit,\n            metadataURI\n        );\n    }\n\n    // ---------- Worker: Apply ----------\n    /**\n     * @notice Apply to a job post with a bid and proposal.\n     * @param postId Target post.\n     * @param bidAmount Bid amount (must be <= budgetMax).\n     * @param proposalURI Proposal IPFS/Arweave URI.\n     */\n    function applyNow(\n        uint256 postId,\n        uint256 bidAmount,\n        string calldata proposalURI\n    ) external returns (uint256 appIndex) {\n        JobPost storage p = posts[postId];\n        require(p.open, \"closed\");\n        require(block.timestamp < p.expiry, \"expired\");\n        require(bidAmount > 0 && bidAmount <= p.budgetMax, \"bad bid\");\n\n        applications[postId].push(\n            Application({\n                worker: msg.sender,\n                bidAmount: bidAmount,\n                proposalURI: proposalURI,\n                withdrawn: false\n            })\n        );\n        appIndex = applications[postId].length - 1;\n\n        emit Applied(postId, appIndex, msg.sender, bidAmount, proposalURI);\n    }\n\n    /**\n     * @notice Worker can withdraw their application.\n     */\n    function withdraw(uint256 postId, uint256 appIndex) external {\n        Application storage a = applications[postId][appIndex];\n        require(a.worker == msg.sender, \"not yours\");\n        require(!a.withdrawn, \"already\");\n        a.withdrawn = true;\n        emit ApplicationWithdrawn(postId, appIndex, msg.sender);\n    }\n\n    // ---------- Hirer: Accept ----------\n    /**\n     * @notice Accept a worker's application, closes the post, spawns a Job in JobManager.\n     * @param params Accept parameters.\n     */\n    function accept(\n        AcceptParams calldata params\n    ) external nonReentrant returns (uint256 jobId) {\n        JobPost storage p = posts[params.postId];\n        require(p.hirer == msg.sender, \"only hirer\");\n        require(p.open, \"closed\");\n        require(block.timestamp < p.expiry, \"expired\");\n\n        Application storage a = applications[params.postId][params.appIndex];\n        require(!a.withdrawn, \"withdrawn\");\n        require(params.worker == a.worker, \"worker mismatch\");\n        require(params.paymentToken == p.paymentToken, \"token mismatch\");\n        require(params.amounts.length > 0, \"milestones required\");\n\n        p.open = false;\n\n        // refund deposit\n        if (p.deposit > 0) {\n            coreToken.safeTransfer(p.hirer, p.deposit);\n            p.deposit = 0;\n        }\n\n        // forward to JobManager\n        IJobManager.CreateJobParams memory jmParams = IJobManager\n            .CreateJobParams({\n                worker: params.worker,\n                paymentToken: params.paymentToken,\n                deadline: params.deadline,\n                metadataURI: params.metadataURI,\n                jobType: params.jobType,\n                amounts: params.amounts,\n                dueDates: params.dueDates,\n                requiresDeliverable: params.requiresDeliverable\n            });\n\n        jobId = jobManager.createJob(jmParams);\n\n        emit ApplicationAccepted(params.postId, params.appIndex, jobId);\n        emit PostClosed(params.postId, msg.sender);\n    }\n\n    // ---------- Hirer: Close ----------\n    /**\n     * @notice Manually close a post and refund deposit.\n     */\n    function close(uint256 postId) external nonReentrant {\n        JobPost storage p = posts[postId];\n        require(p.hirer == msg.sender, \"only hirer\");\n        require(p.open, \"already closed\");\n        p.open = false;\n\n        if (p.deposit > 0) {\n            coreToken.safeTransfer(p.hirer, p.deposit);\n            p.deposit = 0;\n        }\n\n        emit PostClosed(postId, p.hirer);\n    }\n\n    // ---------- Anyone: Expire ----------\n    /**\n     * @notice Expire a post after deadline, slash deposit to treasury.\n     */\n    function expire(uint256 postId) external nonReentrant {\n        JobPost storage p = posts[postId];\n        require(p.open, \"already closed\");\n        require(block.timestamp >= p.expiry, \"not expired\");\n\n        p.open = false;\n\n        if (p.deposit > 0) {\n            coreToken.safeTransfer(treasury, p.deposit);\n            emit PostDepositSlashed(postId, p.hirer, p.deposit);\n            p.deposit = 0;\n        }\n\n        emit PostExpired(postId, p.hirer);\n    }\n\n    // ---------- Admin: Update params ----------\n    function setMinDeposit(uint256 newDeposit) external onlyRole(ADMIN_ROLE) {\n        minDeposit = newDeposit;\n    }\n\n    function setTreasury(address newTreasury) external onlyRole(ADMIN_ROLE) {\n        require(newTreasury != address(0), \"zero\");\n        treasury = newTreasury;\n    }\n\n    function setCoreToken(address newCoreToken) external onlyRole(ADMIN_ROLE) {\n        require(newCoreToken != address(0), \"zero\");\n        coreToken = IERC20(newCoreToken);\n    }\n\n    function setJobManager(\n        address newJobManager\n    ) external onlyRole(ADMIN_ROLE) {\n        require(newJobManager != address(0), \"zero\");\n        jobManager = IJobManager(newJobManager);\n    }\n\n    // ---------- Views ----------\n    function getApplicationsCount(\n        uint256 postId\n    ) external view returns (uint256) {\n        return applications[postId].length;\n    }\n\n    function getApplication(\n        uint256 postId,\n        uint256 appIndex\n    )\n        external\n        view\n        returns (\n            address worker,\n            uint256 bidAmount,\n            string memory proposalURI,\n            bool withdrawn\n        )\n    {\n        Application storage a = applications[postId][appIndex];\n        return (a.worker, a.bidAmount, a.proposalURI, a.withdrawn);\n    }\n\n    // ---------- Storage gap ----------\n    uint256[45] private __gap;\n}\n//\n"
      },
      "project/contracts/hirecore/JobManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title HireCoreJobManager\n * @notice Core onchain contract for managing jobs inside HireCore (Phase 1: direct interactions, no relayer).\n *\n * Features\n * - Job lifecycle: create, fund (ERC20/native/permit), deliver milestones, release payments, dispute/resolve, cancel.\n * - Job types: Simple (one milestone) and Milestone (multiple). (Streaming reserved)\n * - Fees: Protocol fee (bps) snapshotted at creation; discounts via badge tiers.\n * - Integrations: VerseProfile.ensureProfile(), ReputationHub logging.\n * - Safety: UUPS upgradeable, Pausable, ReentrancyGuard, token allowlist, native toggle.\n */\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// ---------- External Interfaces ----------\nimport \"../interfaces/IVerseProfile.sol\";\nimport \"../interfaces/IVerseReputationHub.sol\";\nimport \"../interfaces/IBadgeRegistry.sol\";\n\ninterface IERC20PermitMinimal {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract HireCoreJobManager is\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    // ---------- Roles ----------\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant RESOLVER_ROLE = keccak256(\"RESOLVER_ROLE\");\n\n    // ---------- Types ----------\n    enum JobStatus {\n        Created,\n        Funded,\n        InProgress,\n        Disputed,\n        Completed,\n        Released,\n        Cancelled\n    }\n    enum JobType {\n        Simple,\n        Milestone,\n        Streaming\n    } // Streaming reserved (not enabled in v1)\n\n    struct Milestone {\n        uint256 amount;\n        uint64 dueDate;\n        bool delivered;\n        bool released;\n        bool requiresDeliverable;\n        string deliverableURI;\n        string note;\n    }\n\n    struct Job {\n        address hirer;\n        address worker;\n        address paymentToken; // address(0) = native\n        uint256 totalAmount; // agreed budget\n        uint256 fundedAmount; // escrowed funds (not yet released)\n        uint16 feeBpsAtCreation; // effective fee bps snapshot\n        JobStatus status;\n        JobType jobType;\n        uint64 createdAt;\n        uint64 deadline;\n        string metadataURI;\n        Milestone[] milestones;\n    }\n\n    struct CreateJobParams {\n        address worker;\n        address paymentToken;\n        uint64 deadline;\n        string metadataURI;\n        JobType jobType;\n        uint256[] amounts;\n        uint64[] dueDates;\n        bool[] requiresDeliverable;\n    }\n\n    // ---------- Storage ----------\n    uint256 public nextJobId;\n    mapping(uint256 => Job) private jobs;\n\n    // Protocol config\n    address public treasury;\n    uint16 public baseFeeBps; // e.g., 300 = 3%\n    uint16 public maxFeeBps; // hard cap for baseFeeBps\n    // Premium fee discount (applied to snapshot at creation based on tiers)\n    IBadgeRegistry public badgeRegistry;\n    uint8 public minTierForDiscount;\n    uint16 public workerDiscountBps; // subtract from base if worker >= minTier\n    uint16 public hirerDiscountBps; // subtract from base if hirer  >= minTier\n    uint256[] public tierBadgeIds;\n\n    // Integrations\n    IVerseProfile public verseProfile;\n    IVerseReputationHub public reputationHub;\n\n    // Token allowlist + native toggle\n    mapping(address => bool) public allowedPaymentToken; // ERC20 allowlist\n    bool public nativePaymentsEnabled;\n\n    // ---------- Events ----------\n    event JobCreated(\n        uint256 indexed jobId,\n        address indexed hirer,\n        address indexed worker,\n        JobType jobType,\n        address paymentToken,\n        uint256 totalAmount,\n        uint16 feeBps\n    );\n    event JobFunded(\n        uint256 indexed jobId,\n        address indexed from,\n        uint256 amount,\n        uint256 fundedTotal\n    );\n    event MetadataURIUpdated(uint256 indexed jobId, string newURI);\n    event MilestoneDelivered(\n        uint256 indexed jobId,\n        uint256 indexed milestoneIndex,\n        string deliverableURI,\n        string note\n    );\n    event MilestoneReleased(\n        uint256 indexed jobId,\n        uint256 indexed milestoneIndex,\n        uint256 netToWorker,\n        uint256 feeToTreasury\n    );\n    event JobDisputed(uint256 indexed jobId, string reason);\n    event JobResolved(\n        uint256 indexed jobId,\n        uint256 workerPayout,\n        uint256 hirerRefund,\n        uint256 feeTaken\n    );\n    event JobCancelled(uint256 indexed jobId, uint256 refund);\n    event TreasuryUpdated(address newTreasury);\n    event FeesUpdated(\n        uint16 baseFeeBps,\n        uint16 workerDiscountBps,\n        uint16 hirerDiscountBps,\n        uint8 minTier\n    );\n    event BadgeRegistryUpdated(address badgeRegistry, uint256[] tierBadgeIds);\n    event TokenAllowed(address token, bool allowed);\n    event NativeToggle(bool enabled);\n    event VerseProfileSet(address verseProfile);\n    event ReputationHubSet(address hub);\n\n    // ---------- Constructor (upgrade-safe) ----------\n    constructor() {\n        _disableInitializers();\n    }\n\n    // ---------- Init / Upgrade ----------\n    function initialize(\n        address admin,\n        address treasury_,\n        address verseProfile_,\n        address reputationHub_,\n        uint16 baseFeeBps_,\n        uint16 maxFeeBps_\n    ) external initializer {\n        require(admin != address(0) && treasury_ != address(0), \"bad init\");\n        __UUPSUpgradeable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(ADMIN_ROLE, admin);\n\n        treasury = treasury_;\n        baseFeeBps = baseFeeBps_;\n        maxFeeBps = maxFeeBps_;\n        verseProfile = IVerseProfile(verseProfile_);\n        reputationHub = IVerseReputationHub(reputationHub_);\n        nativePaymentsEnabled = true;\n        nextJobId = 1;\n\n        emit TreasuryUpdated(treasury_);\n        emit FeesUpdated(baseFeeBps_, 0, 0, 0);\n        emit VerseProfileSet(verseProfile_);\n        emit ReputationHubSet(reputationHub_);\n    }\n\n    function _authorizeUpgrade(\n        address\n    ) internal override onlyRole(ADMIN_ROLE) {}\n\n    // Accept native funds if needed\n    receive() external payable {}\n\n    // ======================================================\n    //                       Admin\n    // ======================================================\n\n    function setTreasury(address newTreasury) external onlyRole(ADMIN_ROLE) {\n        require(newTreasury != address(0), \"zero\");\n        treasury = newTreasury;\n        emit TreasuryUpdated(newTreasury);\n    }\n\n    function setFees(\n        uint16 baseFeeBps_,\n        uint16 workerDiscountBps_,\n        uint16 hirerDiscountBps_,\n        uint8 minTier_\n    ) external onlyRole(ADMIN_ROLE) {\n        require(baseFeeBps_ <= maxFeeBps, \"fee>max\");\n        baseFeeBps = baseFeeBps_;\n        workerDiscountBps = workerDiscountBps_;\n        hirerDiscountBps = hirerDiscountBps_;\n        minTierForDiscount = minTier_;\n        emit FeesUpdated(\n            baseFeeBps_,\n            workerDiscountBps_,\n            hirerDiscountBps_,\n            minTier_\n        );\n    }\n\n    function setMaxFeeBps(uint16 maxFeeBps_) external onlyRole(ADMIN_ROLE) {\n        require(maxFeeBps_ >= baseFeeBps, \"max<base\");\n        maxFeeBps = maxFeeBps_;\n        // no event; max cap only guards baseFeeBps\n    }\n\n    function setBadgeRegistry(\n        address reg,\n        uint256[] calldata ids\n    ) external onlyRole(ADMIN_ROLE) {\n        badgeRegistry = IBadgeRegistry(reg);\n        tierBadgeIds = ids;\n        emit BadgeRegistryUpdated(reg, ids);\n    }\n\n    function allowPaymentToken(\n        address token,\n        bool allowed\n    ) external onlyRole(ADMIN_ROLE) {\n        require(token != address(0), \"zero\");\n        allowedPaymentToken[token] = allowed;\n        emit TokenAllowed(token, allowed);\n    }\n\n    function toggleNative(bool enabled) external onlyRole(ADMIN_ROLE) {\n        nativePaymentsEnabled = enabled;\n        emit NativeToggle(enabled);\n    }\n\n    function setVerseProfile(address vp) external onlyRole(ADMIN_ROLE) {\n        verseProfile = IVerseProfile(vp);\n        emit VerseProfileSet(vp);\n    }\n\n    function setReputationHub(address hub) external onlyRole(ADMIN_ROLE) {\n        reputationHub = IVerseReputationHub(hub);\n        emit ReputationHubSet(hub);\n    }\n\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // ======================================================\n    //                 Job Creation & Metadata\n    // ======================================================\n\n    /**\n     * @notice Create a job. For JobType.Simple pass a single milestone via arrays len=1.\n     *         For JobType.Milestone, arrays must be same length (>1).\n     *\n     * @param p createjobparams\n     */\n    function createJob(\n        CreateJobParams calldata p\n    ) external whenNotPaused returns (uint256 jobId) {\n        _validateJob(\n            p.worker,\n            p.paymentToken,\n            p.deadline,\n            p.jobType,\n            p.amounts,\n            p.dueDates,\n            p.requiresDeliverable\n        );\n\n        // ensure Verse profiles\n        uint256 hirerVerseId = verseProfile.profileOf(_msgSender());\n        require(hirerVerseId != 0, \"hirer: no profile\");\n\n        uint256 workerVerseId = verseProfile.profileOf(p.worker);\n        require(workerVerseId != 0, \"worker: no profile\");\n        uint256 total = _sumAmounts(p.amounts);\n        uint16 effFee = _effectiveFeeBps(_msgSender(), p.worker);\n\n        jobId = nextJobId++;\n        _initJob(\n            jobId,\n            p.worker,\n            p.paymentToken,\n            p.deadline,\n            p.metadataURI,\n            p.jobType,\n            total,\n            effFee\n        );\n\n        _addMilestones(jobId, p.amounts, p.dueDates, p.requiresDeliverable);\n\n        emit JobCreated(\n            jobId,\n            _msgSender(),\n            p.worker,\n            p.jobType,\n            p.paymentToken,\n            total,\n            effFee\n        );\n    }\n\n    function _validateJob(\n        address worker,\n        address paymentToken,\n        uint64 deadline,\n        JobType jobType,\n        uint256[] calldata amounts,\n        uint64[] calldata dueDates,\n        bool[] calldata requiresDeliverable\n    ) internal view {\n        require(worker != address(0), \"bad worker\");\n        require(deadline > block.timestamp, \"bad deadline\");\n        require(\n            amounts.length == dueDates.length &&\n                amounts.length == requiresDeliverable.length,\n            \"array len\"\n        );\n        require(amounts.length > 0, \"no milestones\");\n        if (jobType == JobType.Simple) require(amounts.length == 1, \"simple=1\");\n\n        if (paymentToken == address(0)) {\n            require(nativePaymentsEnabled, \"native off\");\n        } else {\n            require(allowedPaymentToken[paymentToken], \"token not allowed\");\n        }\n    }\n\n    function _sumAmounts(\n        uint256[] calldata amounts\n    ) internal pure returns (uint256 total) {\n        for (uint256 i = 0; i < amounts.length; i++) {\n            total += amounts[i];\n        }\n        require(total > 0, \"zero total\");\n    }\n\n    function _initJob(\n        uint256 jobId,\n        address worker,\n        address paymentToken,\n        uint64 deadline,\n        string calldata metadataURI,\n        JobType jobType,\n        uint256 total,\n        uint16 effFee\n    ) internal {\n        Job storage j = jobs[jobId];\n        j.hirer = _msgSender();\n        j.worker = worker;\n        j.paymentToken = paymentToken;\n        j.totalAmount = total;\n        j.fundedAmount = 0;\n        j.feeBpsAtCreation = effFee;\n        j.status = JobStatus.Created;\n        j.jobType = jobType;\n        j.createdAt = uint64(block.timestamp);\n        j.deadline = deadline;\n        j.metadataURI = metadataURI;\n    }\n\n    function _addMilestones(\n        uint256 jobId,\n        uint256[] calldata amounts,\n        uint64[] calldata dueDates,\n        bool[] calldata requiresDeliverable\n    ) internal {\n        Job storage j = jobs[jobId];\n        for (uint256 i = 0; i < amounts.length; i++) {\n            j.milestones.push(\n                Milestone({\n                    amount: amounts[i],\n                    dueDate: dueDates[i],\n                    delivered: false,\n                    released: false,\n                    requiresDeliverable: requiresDeliverable[i],\n                    deliverableURI: \"\",\n                    note: \"\"\n                })\n            );\n        }\n    }\n\n    function updateJobMetadataURI(\n        uint256 jobId,\n        string calldata newURI\n    ) external whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(_msgSender() == j.hirer, \"only hirer\");\n        j.metadataURI = newURI;\n        emit MetadataURIUpdated(jobId, newURI);\n    }\n\n    // ======================================================\n    //                        Funding\n    // ======================================================\n\n    function fundJob(\n        uint256 jobId,\n        uint256 amount\n    ) external nonReentrant whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(j.hirer != address(0), \"no job\");\n        require(j.paymentToken != address(0), \"native job\");\n        require(allowedPaymentToken[j.paymentToken], \"token not allowed\");\n        require(amount > 0, \"zero\");\n        uint256 remain = j.totalAmount - j.fundedAmount;\n        require(remain > 0, \"fully funded\");\n        if (amount > remain) amount = remain;\n\n        IERC20(j.paymentToken).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            amount\n        );\n        j.fundedAmount += amount;\n\n        _afterFundStatusTransition(j);\n\n        emit JobFunded(jobId, _msgSender(), amount, j.fundedAmount);\n    }\n\n    function fundJobWithPermit(\n        uint256 jobId,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(j.hirer != address(0), \"no job\");\n        require(j.paymentToken != address(0), \"native job\");\n        require(allowedPaymentToken[j.paymentToken], \"token not allowed\");\n        require(amount > 0, \"zero\");\n        uint256 remain = j.totalAmount - j.fundedAmount;\n        require(remain > 0, \"fully funded\");\n        if (amount > remain) amount = remain;\n\n        IERC20PermitMinimal(j.paymentToken).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        IERC20(j.paymentToken).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            amount\n        );\n        j.fundedAmount += amount;\n\n        _afterFundStatusTransition(j);\n\n        emit JobFunded(jobId, _msgSender(), amount, j.fundedAmount);\n    }\n\n    function fundJobNative(\n        uint256 jobId\n    ) external payable nonReentrant whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(j.hirer != address(0), \"no job\");\n        require(j.paymentToken == address(0), \"erc20 job\");\n        require(nativePaymentsEnabled, \"native off\");\n        require(msg.value > 0, \"zero\");\n        uint256 remain = j.totalAmount - j.fundedAmount;\n        require(remain > 0, \"fully funded\");\n        uint256 amount = msg.value;\n        require(amount <= remain, \"excess value\");\n\n        j.fundedAmount += amount;\n\n        _afterFundStatusTransition(j);\n\n        emit JobFunded(jobId, _msgSender(), amount, j.fundedAmount);\n    }\n\n    function _afterFundStatusTransition(Job storage j) internal {\n        if (j.status == JobStatus.Created) j.status = JobStatus.Funded;\n        else if (\n            j.status == JobStatus.InProgress ||\n            j.status == JobStatus.Disputed ||\n            j.status == JobStatus.Completed\n        ) {\n            // keep state as-is in these cases\n        }\n    }\n\n    // ======================================================\n    //                Delivery / Release / Dispute\n    // ======================================================\n\n    function deliverMilestone(\n        uint256 jobId,\n        uint256 milestoneIndex,\n        string calldata deliverableURI,\n        string calldata note\n    ) external whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(_msgSender() == j.worker, \"only worker\");\n        require(\n            j.status == JobStatus.Funded || j.status == JobStatus.InProgress,\n            \"state\"\n        );\n        require(milestoneIndex < j.milestones.length, \"idx\");\n\n        Milestone storage m = j.milestones[milestoneIndex];\n        require(!m.delivered, \"already delivered\");\n        if (m.requiresDeliverable) {\n            require(bytes(deliverableURI).length != 0, \"need URI\");\n        }\n\n        m.delivered = true;\n        m.deliverableURI = deliverableURI;\n        m.note = note;\n\n        if (j.status == JobStatus.Funded) j.status = JobStatus.InProgress;\n\n        emit MilestoneDelivered(jobId, milestoneIndex, deliverableURI, note);\n    }\n\n    function releaseMilestone(\n        uint256 jobId,\n        uint256 milestoneIndex\n    ) external nonReentrant whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(_msgSender() == j.hirer, \"only hirer\");\n        require(\n            j.status == JobStatus.InProgress ||\n                j.status == JobStatus.Funded ||\n                j.status == JobStatus.Completed,\n            \"state\"\n        );\n        require(milestoneIndex < j.milestones.length, \"idx\");\n\n        Milestone storage m = j.milestones[milestoneIndex];\n        require(m.delivered && !m.released, \"not deliverable\");\n\n        uint256 amt = m.amount;\n        require(j.fundedAmount >= amt, \"insufficient funded\");\n        j.fundedAmount -= amt;\n        m.released = true;\n\n        // split fee + pay out\n        (uint256 fee, uint256 net) = _splitFee(j.feeBpsAtCreation, amt);\n        _payout(j.paymentToken, j.worker, net);\n        _payout(j.paymentToken, treasury, fee);\n\n        emit MilestoneReleased(jobId, milestoneIndex, net, fee);\n\n        if (address(reputationHub) != address(0)) {\n            uint256 workerVerseId = verseProfile.profileOf(j.worker);\n            reputationHub.logCompleted(workerVerseId, j.paymentToken, net);\n        }\n\n        // update job status\n        bool allReleased = true;\n        for (uint256 i = 0; i < j.milestones.length; i++) {\n            if (!j.milestones[i].released) {\n                allReleased = false;\n                break;\n            }\n        }\n        if (allReleased) {\n            j.status = JobStatus.Released;\n        } else if (j.status == JobStatus.Funded) {\n            j.status = JobStatus.InProgress;\n        }\n    }\n\n    function disputeJob(\n        uint256 jobId,\n        string calldata reason\n    ) external whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(\n            _msgSender() == j.hirer || _msgSender() == j.worker,\n            \"only parties\"\n        );\n        require(\n            j.status == JobStatus.InProgress || j.status == JobStatus.Funded,\n            \"state\"\n        );\n        j.status = JobStatus.Disputed;\n        emit JobDisputed(jobId, reason);\n    }\n\n    /**\n     * @notice Resolver splits currently funded escrow between worker and hirer; fee taken from worker payout.\n     * @param workerPayout gross amount from funded escrow allocated to worker (fee is deducted from this)\n     * @param hirerRefund  amount refunded to hirer\n     */\n    function resolveDispute(\n        uint256 jobId,\n        uint256 workerPayout,\n        uint256 hirerRefund\n    ) external nonReentrant whenNotPaused onlyRole(RESOLVER_ROLE) {\n        Job storage j = jobs[jobId];\n        require(j.status == JobStatus.Disputed, \"not disputed\");\n        require(workerPayout + hirerRefund <= j.fundedAmount, \"exceeds escrow\");\n\n        j.fundedAmount -= (workerPayout + hirerRefund);\n\n        (uint256 fee, uint256 netToWorker) = _splitFee(\n            j.feeBpsAtCreation,\n            workerPayout\n        );\n        _payout(j.paymentToken, j.worker, netToWorker);\n        _payout(j.paymentToken, treasury, fee);\n        _payout(j.paymentToken, j.hirer, hirerRefund);\n\n        j.status = JobStatus.Released; // terminal state after resolution\n        emit JobResolved(jobId, netToWorker, hirerRefund, fee);\n\n        if (address(reputationHub) != address(0)) {\n            uint256 workerVerseId = verseProfile.profileOf(j.worker);\n            if (netToWorker > 0) {\n                reputationHub.logCompleted(\n                    workerVerseId,\n                    j.paymentToken,\n                    netToWorker\n                );\n            } else {\n                reputationHub.logCancelled(workerVerseId);\n            }\n        }\n    }\n\n    /**\n     * @notice Hirer cancels the job (no dispute). Refunds remaining funded escrow to hirer.\n     *         Can be used when no milestones are delivered or parties agree offchain.\n     */\n    function cancelJob(uint256 jobId) external nonReentrant whenNotPaused {\n        Job storage j = jobs[jobId];\n        require(_msgSender() == j.hirer, \"only hirer\");\n        require(\n            j.status == JobStatus.Created ||\n                j.status == JobStatus.Funded ||\n                j.status == JobStatus.InProgress,\n            \"state\"\n        );\n\n        uint256 refund = j.fundedAmount;\n        j.fundedAmount = 0;\n        j.status = JobStatus.Cancelled;\n\n        if (refund > 0) {\n            _payout(j.paymentToken, j.hirer, refund);\n        }\n\n        emit JobCancelled(jobId, refund);\n\n        if (address(reputationHub) != address(0)) {\n            uint256 workerVerseId = verseProfile.profileOf(j.worker);\n            reputationHub.logCancelled(workerVerseId);\n        }\n    }\n\n    // ======================================================\n    //                        Views\n    // ======================================================\n\n    function getJobCore(\n        uint256 jobId\n    )\n        external\n        view\n        returns (\n            address hirer,\n            address worker,\n            address paymentToken,\n            uint256 totalAmount,\n            uint256 fundedAmount,\n            uint16 feeBpsAtCreation,\n            JobStatus status,\n            JobType jobType,\n            uint64 createdAt,\n            uint64 deadline,\n            string memory metadataURI,\n            uint256 milestonesCount\n        )\n    {\n        Job storage j = jobs[jobId];\n        return (\n            j.hirer,\n            j.worker,\n            j.paymentToken,\n            j.totalAmount,\n            j.fundedAmount,\n            j.feeBpsAtCreation,\n            j.status,\n            j.jobType,\n            j.createdAt,\n            j.deadline,\n            j.metadataURI,\n            j.milestones.length\n        );\n    }\n\n    function getMilestone(\n        uint256 jobId,\n        uint256 index\n    )\n        external\n        view\n        returns (\n            uint256 amount,\n            uint64 dueDate,\n            bool delivered,\n            bool released,\n            bool requiresDeliverable,\n            string memory deliverableURI,\n            string memory note\n        )\n    {\n        Milestone storage m = jobs[jobId].milestones[index];\n        return (\n            m.amount,\n            m.dueDate,\n            m.delivered,\n            m.released,\n            m.requiresDeliverable,\n            m.deliverableURI,\n            m.note\n        );\n    }\n\n    // ======================================================\n    //                      Internals\n    // ======================================================\n\n    function _payout(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == address(0)) {\n            (bool ok, ) = to.call{value: amount}(\"\");\n            require(ok, \"native send fail\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _splitFee(\n        uint16 bps,\n        uint256 amount\n    ) internal pure returns (uint256 fee, uint256 net) {\n        fee = (amount * bps) / 10_000;\n        net = amount - fee;\n    }\n\n    function _effectiveFeeBps(\n        address hirer,\n        address worker\n    ) internal view returns (uint16) {\n        uint16 fee = baseFeeBps;\n        if (\n            address(badgeRegistry) != address(0) &&\n            tierBadgeIds.length > 0 &&\n            minTierForDiscount > 0\n        ) {\n            uint8 tWorker = badgeRegistry.tierOf(worker, tierBadgeIds);\n            uint8 tHirer = badgeRegistry.tierOf(hirer, tierBadgeIds);\n            if (tWorker >= minTierForDiscount && workerDiscountBps > 0) {\n                if (fee > workerDiscountBps) fee -= workerDiscountBps;\n                else fee = 0;\n            }\n            if (tHirer >= minTierForDiscount && hirerDiscountBps > 0) {\n                if (fee > hirerDiscountBps) fee -= hirerDiscountBps;\n                else fee = 0;\n            }\n        }\n        // cap to max\n        if (fee > maxFeeBps) fee = maxFeeBps;\n        return fee;\n    }\n\n    // ---------- Storage gap ----------\n    uint256[42] private __gap;\n}\n"
      },
      "project/contracts/interfaces/IBadgeRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IBadgeRegistry\n/// @notice Interface for interacting with the BadgeRegistry contract.\ninterface IBadgeRegistry {\n    // -------- Views --------\n    function soulbound(uint256 badgeId) external view returns (bool);\n\n    function badgeTier(uint256 badgeId) external view returns (uint8);\n\n    function expiryOf(\n        address user,\n        uint256 badgeId\n    ) external view returns (uint256);\n\n    function hasBadge(\n        address user,\n        uint256 badgeId\n    ) external view returns (bool);\n\n    function hasAny(\n        address user,\n        uint256[] calldata badgeIds\n    ) external view returns (bool);\n\n    function tierOf(\n        address user,\n        uint256[] calldata considerIds\n    ) external view returns (uint8);\n\n    // -------- Mutative (apps/admins) --------\n    function mintBadge(address user, uint256 badgeId, uint256 expiry) external;\n\n    function renewBadge(\n        address user,\n        uint256 badgeId,\n        uint256 newExpiry\n    ) external;\n\n    function revokeBadge(address user, uint256 badgeId) external;\n\n    function selfBurn(uint256 badgeId) external;\n\n    // -------- ERC1155 compatibility --------\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address[] calldata tos,\n        uint256 id\n    ) external;\n}\n"
      },
      "project/contracts/interfaces/IJobManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IJobManager\n/// @notice Minimal external interface for the HireCoreJobManager.\n/// @dev Keep this in sync with JobManager implementation and JobBoard usage.\ninterface IJobManager {\n    // ---------- Types ----------\n    enum JobStatus {\n        Created,\n        Funded,\n        InProgress,\n        Disputed,\n        Completed,\n        Released,\n        Cancelled\n    }\n\n    enum JobType {\n        Simple,\n        Milestone,\n        Streaming\n    }\n\n    struct Milestone {\n        uint256 amount;\n        uint64 dueDate;\n        bool delivered;\n        bool released;\n        bool requiresDeliverable;\n        string deliverableURI;\n        string note;\n    }\n\n    struct CreateJobParams {\n        address worker;\n        address paymentToken;    // address(0) = native\n        uint64 deadline;         // unix ts\n        string metadataURI;      // offchain JSON\n        JobType jobType;         // Simple | Milestone (Streaming reserved)\n        uint256[] amounts;       // milestone amounts (len > 0; =1 for Simple)\n        uint64[] dueDates;       // per-milestone due date\n        bool[] requiresDeliverable; // per-milestone flag\n    }\n\n    struct JobCore {\n        address hirer;\n        address worker;\n        address paymentToken;\n        uint256 totalAmount;\n        uint256 fundedAmount;\n        uint16 feeBpsAtCreation;\n        JobStatus status;\n        JobType jobType;\n        uint64 createdAt;\n        uint64 deadline;\n        string metadataURI;\n        uint256 milestonesCount;\n    }\n\n    // ---------- Events ----------\n    event JobCreated(\n        uint256 indexed jobId,\n        address indexed hirer,\n        address indexed worker,\n        JobType jobType,\n        address paymentToken,\n        uint256 totalAmount,\n        uint16 feeBps\n    );\n\n    event JobFunded(\n        uint256 indexed jobId,\n        address indexed from,\n        uint256 amount,\n        uint256 fundedTotal\n    );\n\n    event MetadataURIUpdated(uint256 indexed jobId, string newURI);\n\n    event MilestoneDelivered(\n        uint256 indexed jobId,\n        uint256 indexed milestoneIndex,\n        string deliverableURI,\n        string note\n    );\n\n    event MilestoneReleased(\n        uint256 indexed jobId,\n        uint256 indexed milestoneIndex,\n        uint256 netToWorker,\n        uint256 feeToTreasury\n    );\n\n    event JobDisputed(uint256 indexed jobId, string reason);\n\n    event JobResolved(\n        uint256 indexed jobId,\n        uint256 workerPayout,\n        uint256 hirerRefund,\n        uint256 feeTaken\n    );\n\n    event JobCancelled(uint256 indexed jobId, uint256 refund);\n\n    // ---------- External: Job lifecycle ----------\n    function createJob(CreateJobParams calldata params)\n        external\n        returns (uint256 jobId);\n\n    function updateJobMetadataURI(uint256 jobId, string calldata newURI) external;\n\n    function fundJob(uint256 jobId, uint256 amount) external;\n\n    function fundJobWithPermit(\n        uint256 jobId,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function fundJobNative(uint256 jobId) external payable;\n\n    function deliverMilestone(\n        uint256 jobId,\n        uint256 milestoneIndex,\n        string calldata deliverableURI,\n        string calldata note\n    ) external;\n\n    function releaseMilestone(uint256 jobId, uint256 milestoneIndex) external;\n\n    function disputeJob(uint256 jobId, string calldata reason) external;\n\n    function resolveDispute(\n        uint256 jobId,\n        uint256 workerPayout,\n        uint256 hirerRefund\n    ) external;\n\n    function cancelJob(uint256 jobId) external;\n\n    // ---------- External: Views ----------\n    function getJobCore(uint256 jobId) external view returns (JobCore memory);\n\n    function getMilestone(uint256 jobId, uint256 index)\n        external\n        view\n        returns (Milestone memory);\n}\n"
      },
      "project/contracts/interfaces/IScoreModel.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IScoreModel\n/// @notice Standard interface for per-app scoring models in the Verse.\ninterface IScoreModel {\n    /// @notice Returns the computed score of a given verseId.\n    /// @param verseId The Verse profile ID of the user.\n    /// @return score The computed score (app-specific units, 0 if none).\n    function scoreOf(uint256 verseId) external view returns (uint256 score);\n}\n"
      },
      "project/contracts/interfaces/IVerseAppRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IVerseAppRegistry\n/// @notice Read-only interface for VerseAppRegistry.\ninterface IVerseAppRegistry {\n    struct App {\n        string name;\n        address writer;\n        address scoreModel;\n        uint16 weightBps;   // 0..10000\n        bool active;\n    }\n\n    // Views\n    function getApp(bytes32 appId) external view returns (App memory);\n    function allAppIds() external view returns (bytes32[] memory);\n    function appConfigOf(bytes32 appId) external view returns (\n        address writer,\n        address scoreModel,\n        uint16 weightBps,\n        bool active\n    );\n    function isActive(bytes32 appId) external view returns (bool);\n    function isWriter(bytes32 appId, address candidate) external view returns (bool);\n    function computeAppScore(bytes32 appId, uint256 verseId) external view returns (uint256 rawScore, uint16 weightBps);\n}\n"
      },
      "project/contracts/interfaces/IVerseProfile.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IVerseProfile\n/// @notice Interface for interacting with the VerseProfile identity contract.\ninterface IVerseProfile {\n    struct Profile {\n        address owner; // wallet or smart account\n        string handle; // globally unique, normalized lowercase\n        string metadataURI; // ipfs://... or https://...\n        string purpose; // human-readable purpose\n        address delegate; // optional manager/guardian\n        uint64 createdAt; // block.timestamp\n        uint8 version; // schema version\n        bytes32 dochash; // proof of verification\n    }\n    struct ProfileSum {\n        address owner;\n        string handle;\n        string metadataURI;\n        string purpose;\n        address delegate;\n        uint64 createdAt;\n        uint8 version;\n        bool verified;\n    }\n\n    // -------- Views --------\n    function getProfile(uint256 verseId) external view returns (Profile memory);\n\n    function getDochash(uint256 verseId) external view returns (bytes32);\n\n    function verseIdByHandle(\n        string calldata handle\n    ) external view returns (uint256);\n\n    function verseIdOfOwner(address owner) external view returns (uint256);\n\n    function getAppNickname(\n        uint256 verseId,\n        bytes32 appId\n    ) external view returns (string memory);\n\n    function verseIdByAppNickname(\n        bytes32 appId,\n        string calldata nickname\n    ) external view returns (uint256);\n\n    function hasProfile(address user) external view returns (bool);\n\n    function getDisplayHandle(\n        uint256 verseId,\n        bytes32 appId\n    ) external view returns (string memory);\n\n    function profileOf(address user) external view returns (uint256);\n\n    // -------- Mutative --------\n    function createProfile(\n        string calldata verseHandle,\n        string calldata metadataURI,\n        bytes32 ensNamehash\n    ) external returns (uint256 verseId);\n\n    function setVerseHandle(\n        uint256 verseId,\n        string calldata newHandle\n    ) external;\n\n    function recoverySetOwner(uint256 verseId, address newOwner) external;\n\n    function setHumanVerified(address subject, bytes32 dochash) external;\n\n    function setMetadataURI(uint256 verseId, string calldata newURI) external;\n\n    function transferOwnershipOfProfile(\n        uint256 verseId,\n        address newOwner\n    ) external;\n\n    function setAppNickname(\n        uint256 verseId,\n        bytes32 appId,\n        string calldata nickname\n    ) external;\n}\n"
      },
      "project/contracts/interfaces/IVerseReputationHub.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IVerseReputationHub\n/// @notice Minimal interface for logging reputation-related events in the Verse.\ninterface IVerseReputationHub {\n    /// @notice Log that a profile has completed an action in an app.\n    /// @param verseId The Verse profile ID of the user.\n    /// @param token   The payment/reward token (0 = native).\n    /// @param amount  Amount earned (can be 0 if not relevant).\n    function logCompleted(uint256 verseId, address token, uint256 amount) external;\n\n    /// @notice Log that a profile has cancelled an action in an app.\n    /// @param verseId The Verse profile ID of the user.\n    function logCancelled(uint256 verseId) external;\n\n    /// @notice Get detailed activity for a profile in a given app.\n    /// @param verseId The Verse profile ID.\n    /// @param appId   The apps identifier (keccak256(\"HireCore\"), etc.).\n    /// @param token   Token address to check earned amounts.\n    /// @return completed Count of completed actions.\n    /// @return cancelled Count of cancelled actions.\n    /// @return earned    Total tokens earned for this token.\n    function getActivity(\n        uint256 verseId,\n        bytes32 appId,\n        address token\n    ) external view returns (uint64 completed, uint64 cancelled, uint256 earned);\n\n    /// @notice Get just the raw counts (no token info).\n    function getRawCounts(uint256 verseId, bytes32 appId)\n        external\n        view\n        returns (uint64 completed, uint64 cancelled);\n}\n"
      },
      "project/contracts/interfaces/IVerseScoreAggregator.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IVerseScoreAggregator\n/// @notice Interface for reading global and per-app scores from the VerseScoreAggregator.\ninterface IVerseScoreAggregator {\n    struct AppPart {\n        bytes32 appId;\n        uint256 rawScore;      // score from the app's model\n        uint16  weightBps;     // weighting from registry\n        uint256 weightedScore; // rawScore * weightBps / 10000\n        bool    active;        // registry flag\n        address scoreModel;    // model used (0 if none)\n    }\n\n    /// @notice Registry contract that manages apps\n    function registry() external view returns (address);\n\n    /// @notice Returns total weighted score + per-app breakdown for a verseId\n    function fullScore(uint256 verseId) external view returns (uint256 total, AppPart[] memory parts);\n\n    /// @notice Convenience: just the summed global score\n    function globalScore(uint256 verseId) external view returns (uint256 total);\n\n    /// @notice Per-app score preview (raw + weighted) for one appId\n    function appScore(\n        bytes32 appId,\n        uint256 verseId\n    )\n        external\n        view\n        returns (\n            uint256 raw,\n            uint256 weighted,\n            uint16 weightBps,\n            bool active,\n            address scoreModel\n        );\n}\n"
      },
      "project/contracts/utils/GatingLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IBadgeRegistry as BadgeRegistry } from \"../interfaces/IBadgeRegistry.sol\";\nlibrary GatingLib {\n    /// @notice Returns true if user has an active badge\n    function hasBadge(\n        BadgeRegistry reg,\n        address user,\n        uint256 badgeId\n    ) internal view returns (bool) {\n        if (address(reg) == address(0)) return false; // gracefully handle missing registry\n        return reg.hasBadge(user, badgeId);\n    }\n\n    /// @notice Returns true if user has any badge among given ids\n    function hasAny(\n        BadgeRegistry reg,\n        address user,\n        uint256[] memory badgeIds\n    ) internal view returns (bool) {\n        if (address(reg) == address(0)) return false;\n        return reg.hasAny(user, badgeIds);\n    }\n\n    /// @notice Returns user's tier (0 if no active badges)\n    function tierOf(\n        BadgeRegistry reg,\n        address user,\n        uint256[] memory considerIds\n    ) internal view returns (uint8) {\n        if (address(reg) == address(0)) return 0;\n        return reg.tierOf(user, considerIds);\n    }\n\n    /// @notice Quick helper: check if user meets at least `minTier`\n    function meetsTier(\n        BadgeRegistry reg,\n        address user,\n        uint256[] memory considerIds,\n        uint8 minTier\n    ) internal view returns (bool) {\n        if (address(reg) == address(0)) return false;\n        return reg.tierOf(user, considerIds) >= minTier;\n    }\n}\n"
      }
    }
  }
}